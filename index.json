[{"content":"我们可以在Go语言中十分便捷地开启goroutine去并发地执行任务，但是如何有效的处理并发过程中的错误则是一个很棘手的问题，本文介绍了一些处理并发错误的方法。\n1.recover goroutine中的panic 我们知道可以在代码中使用 recover 来会恢复程序中意想不到的 panic，而 panic 只会触发当前 goroutine 中的 defer 操作。\n例如在下面的示例代码中，无法在 main 函数中 recover 另一个goroutine中引发的 panic。\nfunc f1() { defer func() { if e := recover(); e != nil { fmt.Printf(\u0026#34;recover panic:%v\\n\u0026#34;, e) } }() // 开启一个goroutine执行任务 go func() { fmt.Println(\u0026#34;in goroutine....\u0026#34;) // 只能触发当前goroutine中的defer panic(\u0026#34;panic in goroutine\u0026#34;) }() time.Sleep(time.Second) fmt.Println(\u0026#34;exit\u0026#34;) } 执行上面的 f1 函数会得到如下结果：\nin goroutine.... panic: panic in goroutine goroutine 6 [running]: main.f1.func2() /Users/liwenzhou/workspace/github/the-road-to-learn-golang/ch12/goroutine_recover.go:20 +0x65 created by main.f1 /Users/liwenzhou/workspace/github/the-road-to-learn-golang/ch12/goroutine_recover.go:17 +0x48 Process finished with exit code 2 从输出结果可以看到程序并没有正常退出，而是由于 panic 异常退出了（exit code 2）。\n正如上面示例演示的那样，在启用 goroutine 去执行任务的场景下，如果想要 recover goroutine中可能出现的 panic 就需要在 goroutine 中使用 recover。就像下面的 f2 函数那样。\nfunc f2() { defer func() { if r := recover(); r != nil { fmt.Printf(\u0026#34;recover outer panic:%v\\n\u0026#34;, r) } }() // 开启一个goroutine执行任务 go func() { defer func() { if r := recover(); r != nil { fmt.Printf(\u0026#34;recover inner panic:%v\\n\u0026#34;, r) } }() fmt.Println(\u0026#34;in goroutine....\u0026#34;) // 只能触发当前goroutine中的defer panic(\u0026#34;panic in goroutine\u0026#34;) }() time.Sleep(time.Second) fmt.Println(\u0026#34;exit\u0026#34;) } 执行 f2 函数会得到如下输出结果。\nin goroutine.... recover inner panic:panic in goroutine exit 程序中的 panic 被 recover 成功捕获，程序最终正常退出。\n2.errgroup 在以往演示的并发示例中，我们通常像下面的示例代码那样在 go 关键字后，调用一个函数或匿名函数。\ngo func(){ // ... } go foo() 在之前讲解并发的代码示例中我们默认被并发的那些函数都不会返回错误，但真实的情况往往是事与愿违。\n当我们想要将一个任务拆分成多个子任务交给多个 goroutine 去运行，这时我们该如何获取到子任务可能返回的错误呢？\n假设我们有多个网址需要并发去获取它们的内容，这时候我们会写出类似下面的代码。\n// fetchUrlDemo 并发获取url内容 func fetchUrlDemo() { wg := sync.WaitGroup{} var urls = []string{ \u0026#34;http://pkg.go.dev\u0026#34;, \u0026#34;http://www.liwenzhou.com\u0026#34;, \u0026#34;http://www.yixieqitawangzhi.com\u0026#34;, } for _, url := range urls { wg.Add(1) go func(url string) { defer wg.Done() resp, err := http.Get(url) if err == nil { fmt.Printf(\u0026#34;获取%s成功\\n\u0026#34;, url) resp.Body.Close() } return // 如何将错误返回呢？ }(url) } wg.Wait() // 如何获取goroutine中可能出现的错误呢？ } 执行上述fetchUrlDemo函数得到如下输出结果，由于 http://www.yixieqitawangzhi.com 是我随意编造的一个并不真实存在的 url，所以对它的 HTTP 请求会返回错误。\n获取http://pkg.go.dev成功 获取http://www.liwenzhou.com成功 在上面的示例代码中，我们开启了 3 个 goroutine 分别去获取3个 url 的内容。类似这种将任务分为若干个子任务的场景会有很多，那么我们如何获取子任务中可能出现的错误呢？\nerrgroup 包就是为了解决这类问题而开发的，它能为处理公共任务的子任务而开启的一组 goroutine 提供同步、error 传播和基于context 的取消功能。\nerrgroup 包中定义了一个 Group 类型，它包含了若干个不可导出的字段。\ntype Group struct { cancel func() wg sync.WaitGroup errOnce sync.Once err error } errgroup.Group 提供了Go和Wait两个方法。\nfunc (g *Group) Go(f func() error) Go 函数会在新的 goroutine 中调用传入的函数f。 第一个返回非零错误的调用将取消该Group；下面的Wait方法会返回该错误 func (g *Group) Wait() error Wait 会阻塞直至由上述 Go 方法调用的所有函数都返回，然后从它们返回第一个非nil的错误（如果有）。 下面的示例代码演示了如何使用 errgroup 包来处理多个子任务 goroutine 中可能返回的 error。\n// fetchUrlDemo2 使用errgroup并发获取url内容 func fetchUrlDemo2() error { g := new(errgroup.Group) // 创建等待组（类似sync.WaitGroup） var urls = []string{ \u0026#34;http://pkg.go.dev\u0026#34;, \u0026#34;http://www.liwenzhou.com\u0026#34;, \u0026#34;http://www.yixieqitawangzhi.com\u0026#34;, } for _, url := range urls { url := url // 注意此处声明新的变量 // 启动一个goroutine去获取url内容 g.Go(func() error { resp, err := http.Get(url) if err == nil { fmt.Printf(\u0026#34;获取%s成功\\n\u0026#34;, url) resp.Body.Close() } return err // 返回错误 }) } if err := g.Wait(); err != nil { // 处理可能出现的错误 fmt.Println(err) return err } fmt.Println(\u0026#34;所有goroutine均成功\u0026#34;) return nil } 执行上面的fetchUrlDemo2函数会得到如下输出结果。\n获取http://pkg.go.dev成功 获取http://www.liwenzhou.com成功 Get \u0026#34;http://www.yixieqitawangzhi.com\u0026#34;: dial tcp: lookup www.yixieqitawangzhi.com: no such host 当子任务的 goroutine 中对http://www.yixieqitawangzhi.com 发起 HTTP 请求时会返回一个错误，这个错误会由 errgroup.Group 的 Wait 方法返回。\n通过阅读下方 errgroup.Group 的 Go 方法源码，我们可以看到当任意一个函数 f 返回错误时，会通过g.errOnce.Do只将第一个返回的错误记录，并且如果存在 cancel 方法则会调用cancel。\nfunc (g *Group) Go(f func() error) { g.wg.Add(1) go func() { defer g.wg.Done() if err := f(); err != nil { g.errOnce.Do(func() { g.err = err if g.cancel != nil { g.cancel() } }) } }() } 那么如何创建带有 cancel 方法的 errgroup.Group 呢？\n答案是通过 errorgroup 包提供的 WithContext 函数。\nfunc WithContext(ctx context.Context) (*Group, context.Context) WithContext 函数接收一个父 context，返回一个新的 Group 对象和一个关联的子 context 对象。下面的代码片段是一个官方文档给出的示例。\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;crypto/md5\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;golang.org/x/sync/errgroup\u0026#34; ) // Pipeline demonstrates the use of a Group to implement a multi-stage // pipeline: a version of the MD5All function with bounded parallelism from // https://blog.golang.org/pipelines. func main() { m, err := MD5All(context.Background(), \u0026#34;.\u0026#34;) if err != nil { log.Fatal(err) } for k, sum := range m { fmt.Printf(\u0026#34;%s:\\t%x\\n\u0026#34;, k, sum) } } type result struct { path string sum [md5.Size]byte } // MD5All reads all the files in the file tree rooted at root and returns a map // from file path to the MD5 sum of the file\u0026#39;s contents. If the directory walk // fails or any read operation fails, MD5All returns an error. func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) { // ctx is canceled when g.Wait() returns. When this version of MD5All returns // - even in case of error! - we know that all of the goroutines have finished // and the memory they were using can be garbage-collected. g, ctx := errgroup.WithContext(ctx) paths := make(chan string) g.Go(func() error { return filepath.Walk(root, func(path string, info os.FileInfo, err error) error { if err != nil { return err } if !info.Mode().IsRegular() { return nil } select { case paths \u0026lt;- path: case \u0026lt;-ctx.Done(): return ctx.Err() } return nil }) }) // Start a fixed number of goroutines to read and digest files. c := make(chan result) const numDigesters = 20 for i := 0; i \u0026lt; numDigesters; i++ { g.Go(func() error { for path := range paths { data, err := ioutil.ReadFile(path) if err != nil { return err } select { case c \u0026lt;- result{path, md5.Sum(data)}: case \u0026lt;-ctx.Done(): return ctx.Err() } } return nil }) } go func() { g.Wait() close(c) }() m := make(map[string][md5.Size]byte) for r := range c { m[r.path] = r.sum } // Check whether any of the goroutines failed. Since g is accumulating the // errors, we don\u0026#39;t need to send them (or check for them) in the individual // results sent on the channel. if err := g.Wait(); err != nil { return nil, err } return m, nil } 或者这里有另外一个示例。\nfunc GetFriends(ctx context.Context, user int64) (map[string]*User, error) { g, ctx := errgroup.WithContext(ctx) friendIds := make(chan int64) // Produce g.Go(func() error { defer close(friendIds) for it := GetFriendIds(user); ; { if id, err := it.Next(ctx); err != nil { if err == io.EOF { return nil } return fmt.Errorf(\u0026#34;GetFriendIds %d: %s\u0026#34;, user, err) } else { select { case \u0026lt;-ctx.Done(): return ctx.Err() case friendIds \u0026lt;- id: } } } }) friends := make(chan *User) // Map workers := int32(nWorkers) for i := 0; i \u0026lt; nWorkers; i++ { g.Go(func() error { defer func() { // Last one out closes shop if atomic.AddInt32(\u0026amp;workers, -1) == 0 { close(friends) } }() for id := range friendIds { if friend, err := GetUserProfile(ctx, id); err != nil { return fmt.Errorf(\u0026#34;GetUserProfile %d: %s\u0026#34;, user, err) } else { select { case \u0026lt;-ctx.Done(): return ctx.Err() case friends \u0026lt;- friend: } } } return nil }) } // Reduce ret := map[string]*User{} g.Go(func() error { for friend := range friends { ret[friend.Name] = friend } return nil }) return ret, g.Wait() } 可惜这两个示例不太好理解。。。\n","permalink":"https://N3bu74.github.io/posts/tech/golang_concurrent_error/","summary":"我们可以在Go语言中十分便捷地开启goroutine去并发地执行任务，但是如何有效的处理并发过程中的错误则是一个很棘手的问题，本文介绍了一些处理并发错误的方法。 1.recover goroutine中的panic 我们知道可以在代码中使用 recover 来会恢复程序中意想不到的 panic，而 panic 只会触发当前 goroutine 中的 defer","title":"Golang 处理并发错误"},{"content":"并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，我们无一例外的想让我们的程序运行的快一点、再快一点。Go语言在语言层面天生支持并发，充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。\n1.基本概念 首先我们先来了解几个与并发编程相关的基本概念。\n1.1 串行、并发与并行 串行：我们都是先读小学，小学毕业后再读初中，读完初中再读高中。\n并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。\n并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。\n1.2 进程、线程和协程 进程（process）：程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。\n线程（thread）：操作系统基于进程开启的轻量级进程，是操作系统调度执行的最小单位。\n协程（coroutine）：非操作系统提供而是由用户自行创建和控制的用户态‘线程’，比线程更轻量级。\n1.3 并发模型 业界将如何实现并发编程总结归纳为各式各样的并发模型，常见的并发模型有以下几种：\n线程\u0026amp;锁模型 Actor模型 CSP模型 Fork\u0026amp;Join模型 Go语言中的并发程序主要是通过基于CSP（communicating sequential processes）的goroutine和channel来实现，当然也支持使用传统的多线程共享内存的并发方式。\n2.goroutine Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。例如Go运行时会智能地将 m个goroutine 合理地分配给n个操作系统线程，实现类似m:n的调度机制，不再需要Go开发者自行在代码层面维护一个线程池。\nGoroutine 是 Go 程序中最基本的并发执行单元。每一个 Go 程序都至少包含一个 goroutine——main goroutine，当 Go 程序启动时它会自动创建。\n在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能——goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数就可以了，就是这么简单粗暴。\n2.1 go关键字 Go语言中使用 goroutine 非常简单，只需要在函数或方法调用前加上go关键字就可以创建一个 goroutine ，从而让该函数或方法在新创建的 goroutine 中执行。\ngo f() // 创建一个新的 goroutine 运行函数f 匿名函数也支持使用go关键字创建 goroutine 去执行。\ngo func(){ // ... }() 一个 goroutine 必定对应一个函数/方法，可以创建多个 goroutine 去执行相同的函数/方法。\n2.2 启动单个goroutine 启动 goroutine 的方式非常简单，只需要在调用函数（普通函数和匿名函数）前加上一个go关键字。\n我们先来看一个在 main 函数中执行普通函数调用的示例。\npackage main import ( \u0026#34;fmt\u0026#34; ) func hello() { fmt.Println(\u0026#34;hello\u0026#34;) } func main() { hello() fmt.Println(\u0026#34;你好\u0026#34;) } 将上面的代码编译后执行，得到的结果如下：\nhello 你好 代码中 hello 函数和其后面的打印语句是串行的。\n接下来我们在调用 hello 函数前面加上关键字go，也就是启动一个 goroutine 去执行 hello 这个函数。\nfunc main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\u0026#34;main goroutine done!\u0026#34;) } 将上述代码重新编译后执行，得到输出结果如下。\n你好 这一次的执行结果只在终端打印了”你好”，并没有打印 hello。这是为什么呢？\n其实在 Go 程序启动时，Go 程序就会为 main 函数创建一个默认的 goroutine 。在上面的代码中我们在 main 函数中使用 go 关键字创建了另外一个 goroutine 去执行 hello 函数，而此时 main goroutine 还在继续往下执行，我们的程序中此时存在两个并发执行的 goroutine。当 main 函数结束时整个程序也就结束了，同时 main goroutine 也结束了，所有由 main goroutine 创建的 goroutine 也会一同退出。也就是说我们的 main 函数退出太快，另外一个 goroutine 中的函数还未执行完程序就退出了，导致未打印出“hello”。\nmain goroutine 就像是《权利的游戏》中的夜王，其他的 goroutine 都是夜王转化出的异鬼，夜王一死它转化的那些异鬼也就全部GG了。\n所以我们要想办法让 main 函数‘“等一等”将在另一个 goroutine 中运行的 hello 函数。其中最简单粗暴的方式就是在 main 函数中“time.Sleep”一秒钟了（这里的1秒钟只是我们为了保证新的 goroutine 能够被正常创建和执行而设置的一个值）。\n按如下方式修改我们的示例代码。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello() { fmt.Println(\u0026#34;hello\u0026#34;) } func main() { go hello() fmt.Println(\u0026#34;你好\u0026#34;) time.Sleep(time.Second) } 将我们的程序重新编译后再次执行，程序会在终端输出如下结果，并且会短暂停顿一会儿。\n你好 hello 为什么会先打印你好呢？\n这是因为在程序中创建 goroutine 执行函数需要一定的开销，而与此同时 main 函数所在的 goroutine 是继续执行的。\n在上面的程序中使用time.Sleep让 main goroutine 等待 hello goroutine执行结束是不优雅的，当然也是不准确的。\nGo 语言中通过sync包为我们提供了一些常用的并发原语，我们会在后面的小节单独介绍sync包中的内容。在这一小节，我们会先介绍一下 sync 包中的WaitGroup。当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，WaitGroup是实现等待一组并发操作完成的好方法。\n下面的示例代码中我们在 main goroutine 中使用sync.WaitGroup来等待 hello goroutine 完成后再退出。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // 声明全局等待组变量 var wg sync.WaitGroup func hello() { fmt.Println(\u0026#34;hello\u0026#34;) wg.Done() // 告知当前goroutine完成 } func main() { wg.Add(1) // 登记1个goroutine go hello() fmt.Println(\u0026#34;你好\u0026#34;) wg.Wait() // 阻塞等待登记的goroutine完成 } 将代码编译后再执行，得到的输出结果和之前一致，但是这一次程序不再会有多余的停顿，hello goroutine 执行完毕后程序直接退出。\n2.3 启动多个goroutine 在 Go 语言中实现并发就是这样简单，我们还可以启动多个 goroutine 。让我们再来看一个新的代码示例。这里同样使用了sync.WaitGroup来实现 goroutine 的同步。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(\u0026#34;hello\u0026#34;, i) } func main() { for i := 0; i \u0026lt; 10; i++ { wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) } wg.Wait() // 等待所有登记的goroutine都结束 } 多次执行上面的代码会发现每次终端上打印数字的顺序都不一致。这是因为10个 goroutine 是并发执行的，而 goroutine 的调度是随机的。\n2.4 动态栈 操作系统的线程一般都有固定的栈内存（通常为2MB）,而 Go 语言中的 goroutine 非常轻量级，一个 goroutine 的初始栈空间很小（一般为2KB），所以在 Go 语言中一次创建数万个 goroutine 也是可能的。并且 goroutine 的栈不是固定的，可以根据需要动态地增大或缩小， Go 的 runtime 会自动为 goroutine 分配合适的栈空间。\n2.5 goroutine调度 操作系统内核在调度时会挂起当前正在执行的线程并将寄存器中的内容保存到内存中，然后选出接下来要执行的线程并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。从一个线程切换到另一个线程需要完整的上下文切换。因为可能需要多次内存访问，索引这个切换上下文的操作开销较大，会增加运行的cpu周期。\n区别于操作系统内核调度操作系统线程，goroutine 的调度是Go语言运行时（runtime）层面的实现，是完全由 Go 语言本身实现的一套调度系统——go scheduler。它的作用是按照一定的规则将所有的 goroutine 调度到操作系统线程上执行。\n在经历数个版本的迭代之后，目前 Go 语言的调度器采用的是 GPM 调度模型。\n其中：\nG：表示 goroutine，每执行一次go f()就创建一个 G，包含要执行的函数和上下文信息。 全局队列（Global Queue）：存放等待运行的 G。 P：表示 goroutine 执行所需的资源，最多有 GOMAXPROCS 个。 P 的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果本地队列满了会批量移动部分 G 到全局队列。 M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，当 P 的本地队列为空时，M 也会尝试从全局队列或其他 P 的本地队列获取 G。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 Goroutine 调度器和操作系统调度器是通过 M 结合起来的，每个 M 都代表了1个内核线程，操作系统调度器负责把内核线程分配到 CPU 的核上执行。 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的， goroutine 则是由Go运行时（runtime）自己的调度器调度的，完全是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身 goroutine 的超轻量级，以上种种特性保证了 goroutine 调度方面的性能。\n2.6 GOMAXPROCS Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的 CPU 核心数。例如在一个 8 核心的机器上，GOMAXPROCS 默认为 8。Go语言中可以通过runtime.GOMAXPROCS函数设置当前程序并发时占用的 CPU逻辑核心数。（Go1.5版本之前，默认使用的是单核心执行。Go1.5 版本之后，默认使用全部的CPU 逻辑核心数。）\n2.7 练习题 请写出下面程序的执行结果。 for i := 0; i \u0026lt; 5; i++ { go func() { fmt.Println(i) }() } 3.channel 单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。\n虽然可以使用共享内存进行数据交换，但是共享内存在不同的 goroutine 中容易发生竞态问题。为了保证数据交换的正确性，很多并发模型中必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。\nGo语言采用的并发模型是CSP（Communicating Sequential Processes），提倡通过通信共享内存而不是通过共享内存而实现通信。\n如果说 goroutine 是Go程序并发的执行体，channel就是它们之间的连接。channel是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。\nGo 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。\n3.1 channel类型 channel是 Go 语言中一种特有的类型。声明通道类型变量的格式如下：\nvar 变量名称 chan 元素类型 其中：\nchan：是关键字 元素类型：是指通道中传递元素的类型 举几个例子：\nvar ch1 chan int // 声明一个传递整型的通道 var ch2 chan bool // 声明一个传递布尔型的通道 var ch3 chan []int // 声明一个传递int切片的通道 3.2 channel零值 未初始化的通道类型变量其默认零值是nil。\nvar ch chan int fmt.Println(ch) // \u0026lt;nil\u0026gt; 3.3 初始化channel 声明的通道类型变量需要使用内置的make函数初始化之后才能使用。具体格式如下：\nmake(chan 元素类型, [缓冲大小]) 其中：\nchannel的缓冲大小是可选的。 举几个例子：\nch4 := make(chan int) ch5 := make(chan bool, 1) // 声明一个缓冲区大小为1的通道 3.4 channel操作 通道共有发送（send）、接收(receive）和关闭（close）三种操作。而发送和接收操作都使用\u0026lt;-符号。\n现在我们先使用以下语句定义一个通道：\nch := make(chan int) 3.4.1 发送 将一个值发送到通道中。\nch \u0026lt;- 10 // 把10发送到ch中 3.4.2 接收 从一个通道中接收值。\nx := \u0026lt;- ch // 从ch中接收值并赋值给变量x \u0026lt;-ch // 从ch中接收值，忽略结果 3.4.3 关闭 我们通过调用内置的close函数来关闭通道。\nclose(ch) **注意：**一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。\n关闭后的通道有以下特点：\n对一个关闭的通道再发送值就会导致 panic。 对一个关闭的通道进行接收会一直获取值直到通道为空。 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 关闭一个已经关闭的通道会导致 panic。 3.5 无缓冲的通道 无缓冲的通道又称为阻塞的通道。我们来看一下如下代码片段。\nfunc main() { ch := make(chan int) ch \u0026lt;- 10 fmt.Println(\u0026#34;发送成功\u0026#34;) } 上面这段代码能够通过编译，但是执行的时候会出现以下错误：\nfatal error: all goroutines are asleep - deadlock! goroutine 1 [chan send]: main.main() .../main.go:8 +0x54 deadlock表示我们程序中的 goroutine 都被挂起导致程序死锁了。为什么会出现deadlock错误呢？\n因为我们使用ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有接收方能够接收值的时候才能发送成功，否则会一直处于等待发送的阶段。同理，如果对一个无缓冲通道执行接收操作时，没有任何向通道中发送值的操作那么也会导致接收操作阻塞。就像田径比赛中的4x100接力赛，想要完成交棒必须有一个能够接棒的运动员，否则只能等待。简单来说就是无缓冲的通道必须有至少一个接收方才能发送成功。\n上面的代码会阻塞在ch \u0026lt;- 10这一行代码形成死锁，那如何解决这个问题呢？\n其中一种可行的方法是创建一个 goroutine 去接收值，例如：\nfunc recv(c chan int) { ret := \u0026lt;-c fmt.Println(\u0026#34;接收成功\u0026#34;, ret) } func main() { ch := make(chan int) go recv(ch) // 创建一个 goroutine 从通道接收值 ch \u0026lt;- 10 fmt.Println(\u0026#34;发送成功\u0026#34;) } 首先无缓冲通道ch上的发送操作会阻塞，直到另一个 goroutine 在该通道上执行接收操作，这时数字10才能发送成功，两个 goroutine 将继续执行。相反，如果接收操作先执行，接收方所在的 goroutine 将阻塞，直到 main goroutine 中向该通道发送数字10。\n使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为同步通道。\n3.6 有缓冲的通道 还有另外一种解决上面死锁问题的方法，那就是使用有缓冲区的通道。我们可以在使用 make 函数初始化通道时，可以为其指定通道的容量，例如：\nfunc main() { ch := make(chan int, 1) // 创建一个容量为1的有缓冲区通道 ch \u0026lt;- 10 fmt.Println(\u0026#34;发送成功\u0026#34;) } 只要通道的容量大于零，那么该通道就属于有缓冲的通道，通道的容量表示通道中最大能存放的元素数量。当通道内已有元素数达到最大容量后，再向通道执行发送操作就会阻塞，除非有从通道执行接收操作。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。\n我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。\n3.7 多返回值模式 当向通道中发送完数据时，我们可以通过close函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？\n对一个通道执行接收操作时支持使用如下多返回值模式。\nvalue, ok := \u0026lt;- ch 其中：\nvalue：从通道中取出的值，如果通道被关闭则返回对应类型的零值。 ok：通道ch关闭时返回 false，否则返回 true。 下面代码片段中的f2函数会循环从通道ch中接收所有值，直到通道被关闭后退出。\nfunc f2(ch chan int) { for { v, ok := \u0026lt;-ch if !ok { fmt.Println(\u0026#34;通道已关闭\u0026#34;) break } fmt.Printf(\u0026#34;v:%#v ok:%#v\\n\u0026#34;, v, ok) } } func main() { ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 close(ch) f2(ch) } 3.8 for range接收值 通常我们会选择使用for range循环从通道中接收值，当通道被关闭后，会在通道内的所有值被接收完毕后会自动退出循环。上面那个示例我们使用for range改写后会很简洁。\nfunc f3(ch chan int) { for v := range ch { fmt.Println(v) } } **注意：**目前Go语言中并没有提供一个不对通道进行读取操作就能判断通道是否被关闭的方法。不能简单的通过len(ch)操作来判断通道是否被关闭。\n3.9 单向通道 在某些场景下我们可能会将通道作为参数在多个任务函数间进行传递，通常我们会选择在不同的任务函数中对通道的使用进行限制，比如限制通道在某个函数中只能执行发送或只能执行接收操作。想象一下，我们现在有Producer和Consumer两个函数，其中Producer函数会返回一个通道，并且会持续将符合条件的数据发送至该通道，并在发送完成后将该通道关闭。而Consumer函数的任务是从通道中接收值进行计算，这两个函数之间通过Processer函数返回的通道进行通信。完整的示例代码如下。\npackage main import ( \u0026#34;fmt\u0026#34; ) // Producer 返回一个通道 // 并持续将符合条件的数据发送至返回的通道中 // 数据发送完成后会将返回的通道关闭 func Producer() chan int { ch := make(chan int, 2) // 创建一个新的goroutine执行发送数据的任务 go func() { for i := 0; i \u0026lt; 10; i++ { if i%2 == 1 { ch \u0026lt;- i } } close(ch) // 任务完成后关闭通道 }() return ch } // Consumer 从通道中接收数据进行计算 func Consumer(ch chan int) int { sum := 0 for v := range ch { sum += v } return sum } func main() { ch := Producer() res := Consumer(ch) fmt.Println(res) // 25 } 从上面的示例代码中可以看出正常情况下Consumer函数中只会对通道进行接收操作，但是这不代表不可以在Consumer函数中对通道进行发送操作。作为Producer函数的提供者，我们在返回通道的时候可能只希望调用方拿到返回的通道后只能对其进行接收操作。但是我们没有办法阻止在Consumer函数中对通道进行发送操作。\nGo语言中提供了单向通道来处理这种需要限制通道只能进行某种操作的情况。\n\u0026lt;- chan int // 只接收通道，只能接收不能发送 chan \u0026lt;- int // 只发送通道，只能发送不能接收 其中，箭头\u0026lt;-和关键字chan的相对位置表明了当前通道允许的操作，这种限制将在编译阶段进行检测。另外对一个只接收通道执行close也是不允许的，因为默认通道的关闭操作应该由发送方来完成。\n我们使用单向通道将上面的示例代码进行如下改造。\n// Producer2 返回一个接收通道 func Producer2() \u0026lt;-chan int { ch := make(chan int, 2) // 创建一个新的goroutine执行发送数据的任务 go func() { for i := 0; i \u0026lt; 10; i++ { if i%2 == 1 { ch \u0026lt;- i } } close(ch) // 任务完成后关闭通道 }() return ch } // Consumer2 参数为接收通道 func Consumer2(ch \u0026lt;-chan int) int { sum := 0 for v := range ch { sum += v } return sum } func main() { ch2 := Producer2() res2 := Consumer2(ch2) fmt.Println(res2) // 25 } 这一次，Producer函数返回的是一个只接收通道，这就从代码层面限制了该函数返回的通道只能进行接收操作，保证了数据安全。很多读者看到这个示例可能会觉着这样的限制是多余的，但是试想一下如果Producer函数可以在其他地方被其他人调用，你该如何限制他人不对该通道执行发送操作呢？并且返回限制操作的单向通道也会让代码语义更清晰、更易读。\n在函数传参及任何赋值操作中全向通道（正常通道）可以转换为单向通道，但是无法反向转换。\nvar ch3 = make(chan int, 1) ch3 \u0026lt;- 10 close(ch3) Consumer2(ch3) // 函数传参时将ch3转为单向通道 var ch4 = make(chan int, 1) ch4 \u0026lt;- 10 var ch5 \u0026lt;-chan int // 声明一个只接收通道ch5 ch5 = ch4 // 变量赋值时将ch4转为单向通道 \u0026lt;-ch5 3.10 总结 下面的表格中总结了对不同状态下的通道执行相应操作的结果。\n注意：对已经关闭的通道再执行 close 也会引发 panic。\n4. select多路复用 在某些场景下我们可能需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以被接收那么当前 goroutine 将会发生阻塞。你也许会写出如下代码尝试使用遍历的方式来实现从多个通道中接收值。\nfor{ // 尝试从ch1接收值 data, ok := \u0026lt;-ch1 // 尝试从ch2接收值 data, ok := \u0026lt;-ch2 … } 这种方式虽然可以实现从多个通道接收值的需求，但是程序的运行性能会差很多。Go 语言内置了select关键字，使用它可以同时响应多个通道的操作。\nSelect 的使用方式类似于之前学到的 switch 语句，它也有一系列 case 分支和一个默认的分支。每个 case 分支会对应一个通道的通信（接收或发送）过程。select 会一直等待，直到其中的某个 case 的通信操作完成时，就会执行该 case 分支对应的语句。具体格式如下：\nselect { case \u0026lt;-ch1: //... case data := \u0026lt;-ch2: //... case ch3 \u0026lt;- 10: //... default: //默认操作 } Select 语句具有以下特点。\n可处理一个或多个 channel 的发送/接收操作。 如果多个 case 同时满足，select 会随机选择一个执行。 对于没有 case 的 select 会一直阻塞，可用于阻塞 main 函数，防止退出。 下面的示例代码能够在终端打印出10以内的奇数，我们借助这个代码片段来看一下 select 的具体使用。\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 1) for i := 1; i \u0026lt;= 10; i++ { select { case x := \u0026lt;-ch: fmt.Println(x) case ch \u0026lt;- i: } } } 上面的代码输出内容如下。\n1 3 5 7 9 示例中的代码首先是创建了一个缓冲区大小为1的通道 ch，进入 for 循环后：\n第一次循环时 i = 1，select 语句中包含两个 case 分支，此时由于通道中没有值可以接收，所以x := \u0026lt;-ch 这个 case 分支不满足，而ch \u0026lt;- i这个分支可以执行，会把1发送到通道中，结束本次 for 循环； 第二次 for 循环时，i = 2，由于通道缓冲区已满，所以ch \u0026lt;- i这个分支不满足，而x := \u0026lt;-ch这个分支可以执行，从通道接收值1并赋值给变量 x ，所以会在终端打印出 1； 后续的 for 循环以此类推会依次打印出3、5、7、9。 5.通道误用示例 接下来，我们将展示两个因误用通道导致程序出现 bug 的代码片段，希望能够加深读者对通道操作的印象。\n示例1 各位读者可以查看以下示例代码，尝试找出其中存在的问题。\n// demo1 通道误用导致的bug func demo1() { wg := sync.WaitGroup{} ch := make(chan int, 10) for i := 0; i \u0026lt; 10; i++ { ch \u0026lt;- i } close(ch) wg.Add(3) for j := 0; j \u0026lt; 3; j++ { go func() { for { task := \u0026lt;-ch // 这里假设对接收的数据执行某些操作 fmt.Println(task) } wg.Done() }() } wg.Wait() } 将上述代码编译执行后，匿名函数所在的 goroutine 并不会按照预期在通道被关闭后退出。因为task := \u0026lt;- ch的接收操作在通道被关闭后会一直接收到零值，而不会退出。此处的接收操作应该使用task, ok := \u0026lt;- ch，通过判断布尔值ok为假时退出；或者使用select 来处理通道。\n示例2 各位读者阅读下方代码片段，尝试找出其中存在的问题。\n// demo2 通道误用导致的bug func demo2() { ch := make(chan string) go func() { // 这里假设执行一些耗时的操作 time.Sleep(3 * time.Second) ch \u0026lt;- \u0026#34;job result\u0026#34; }() select { case result := \u0026lt;-ch: fmt.Println(result) case \u0026lt;-time.After(time.Second): // 较小的超时时间 return } } 上述代码片段可能导致 goroutine 泄露（goroutine 并未按预期退出并销毁）。由于 select 命中了超时逻辑，导致通道没有消费者（无接收操作），而其定义的通道为无缓冲通道，因此 goroutine 中的ch \u0026lt;- \u0026quot;job result\u0026quot;操作会一直阻塞，最终导致 goroutine 泄露。\n6.并发安全和锁 有时候我们的代码中可能会存在多个 goroutine 同时操作一个资源（临界区）的情况，这种情况下就会发生竞态问题（数据竞态）。这就好比现实生活中十字路口被各个方向的汽车竞争，还有火车上的卫生间被车厢里的人竞争。\n我们用下面的代码演示一个数据竞争的示例。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var ( x int64 wg sync.WaitGroup // 等待组 ) // add 对全局变量x执行5000次加1操作 func add() { for i := 0; i \u0026lt; 5000; i++ { x = x + 1 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 我们将上面的代码编译后执行，不出意外每次执行都会输出诸如9537、5865、6527等不同的结果。这是为什么呢？\n在上面的示例代码片中，我们开启了两个 goroutine 分别执行 add 函数，这两个 goroutine 在访问和修改全局的x变量时就会存在数据竞争，某个 goroutine 中对全局变量x的修改可能会覆盖掉另一个 goroutine 中的操作，所以导致最后的结果与预期不符。\n6.1 互斥锁 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同一时间只有一个 goroutine 可以访问共享资源。Go 语言中使用sync包中提供的Mutex类型来实现互斥锁。\nsync.Mutex提供了两个方法供我们使用。\n方法名 功能 func (m *Mutex) Lock() 获取互斥锁 func (m *Mutex) Unlock() 释放互斥锁 我们在下面的示例代码中使用互斥锁限制每次只有一个 goroutine 才能修改全局变量x，从而修复上面代码中的问题。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) // sync.Mutex var ( x int64 wg sync.WaitGroup // 等待组 m sync.Mutex // 互斥锁 ) // add 对全局变量x执行5000次加1操作 func add() { for i := 0; i \u0026lt; 5000; i++ { m.Lock() // 修改x前加锁 x = x + 1 m.Unlock() // 改完解锁 } wg.Done() } func main() { wg.Add(2) go add() go add() wg.Wait() fmt.Println(x) } 将上面的代码编译后多次执行，每一次都会得到预期中的结果——10000。\n使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。\n6.2 读写互斥锁 互斥锁是完全互斥的，但是实际上有很多场景是读多写少的，当我们并发的去读取一个资源而不涉及资源修改的时候是没有必要加互斥锁的，这种场景下使用读写锁是更好的一种选择。读写锁在 Go 语言中使用sync包中的RWMutex类型。\nsync.RWMutex提供了以下5个方法。\n方法名 功能 func (rw *RWMutex) Lock() 获取写锁 func (rw *RWMutex) Unlock() 释放写锁 func (rw *RWMutex) RLock() 获取读锁 func (rw *RWMutex) RUnlock() 释放读锁 func (rw *RWMutex) RLocker() Locker 返回一个实现Locker接口的读写锁 读写锁分为两种：读锁和写锁。当一个 goroutine 获取到读锁之后，其他的 goroutine 如果是获取读锁会继续获得锁，如果是获取写锁就会等待；而当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。\n下面我们使用代码构造一个读多写少的场景，然后分别使用互斥锁和读写锁查看它们的性能差异。\nvar ( x int64 wg sync.WaitGroup mutex sync.Mutex rwMutex sync.RWMutex ) // writeWithLock 使用互斥锁的写操作 func writeWithLock() { mutex.Lock() // 加互斥锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 mutex.Unlock() // 解互斥锁 wg.Done() } // readWithLock 使用互斥锁的读操作 func readWithLock() { mutex.Lock() // 加互斥锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 mutex.Unlock() // 释放互斥锁 wg.Done() } // writeWithLock 使用读写互斥锁的写操作 func writeWithRWLock() { rwMutex.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwMutex.Unlock() // 释放写锁 wg.Done() } // readWithRWLock 使用读写互斥锁的读操作 func readWithRWLock() { rwMutex.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwMutex.RUnlock() // 释放读锁 wg.Done() } func do(wf, rf func(), wc, rc int) { start := time.Now() // wc个并发写操作 for i := 0; i \u0026lt; wc; i++ { wg.Add(1) go wf() } // rc个并发读操作 for i := 0; i \u0026lt; rc; i++ { wg.Add(1) go rf() } wg.Wait() cost := time.Since(start) fmt.Printf(\u0026#34;x:%v cost:%v\\n\u0026#34;, x, cost) } 我们假设每一次读操作都会耗时1ms，而每一次写操作会耗时10ms，我们分别测试使用互斥锁和读写互斥锁执行10次并发写和1000次并发读的耗时数据。\n// 使用互斥锁，10并发写，1000并发读 do(writeWithLock, readWithLock, 10, 1000) // x:10 cost:1.466500951s // 使用读写互斥锁，10并发写，1000并发读 do(writeWithRWLock, readWithRWLock, 10, 1000) // x:10 cost:117.207592ms 从最终的执行结果可以看出，使用读写互斥锁在读多写少的场景下能够极大地提高程序的性能。不过需要注意的是如果一个程序中的读操作和写操作数量级差别不大，那么读写互斥锁的优势就发挥不出来。\n6.3 sync.WaitGroup 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 sync.WaitGroup有以下几个方法：\n方法名 功能 func (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 Done 方法将计数器减1。通过调用 Wait 来等待并发任务执行完，当计数器值为 0 时，表示所有并发任务已经完成。\n我们利用sync.WaitGroup将上面的代码优化一下：\nvar wg sync.WaitGroup func hello() { defer wg.Done() fmt.Println(\u0026#34;Hello Goroutine!\u0026#34;) } func main() { wg.Add(1) go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\u0026#34;main goroutine done!\u0026#34;) wg.Wait() } 需要注意sync.WaitGroup是一个结构体，进行参数传递的时候要传递指针。\n6.4 sync.Once 在某些场景下我们需要确保某些操作即使在高并发的场景下也只会被执行一次，例如只加载一次配置文件等。\nGo语言中的sync包中提供了一个针对只执行一次场景的解决方案——sync.Once，sync.Once只有一个Do方法，其签名如下：\nfunc (o *Once) Do(f func()) **注意：**如果要执行的函数f需要传递参数就需要搭配闭包来使用。\n6.4.1 加载配置文件示例 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：\nvar icons map[string]image.Image func loadIcons() { icons = map[string]image.Image{ \u0026#34;left\u0026#34;: loadIcon(\u0026#34;left.png\u0026#34;), \u0026#34;up\u0026#34;: loadIcon(\u0026#34;up.png\u0026#34;), \u0026#34;right\u0026#34;: loadIcon(\u0026#34;right.png\u0026#34;), \u0026#34;down\u0026#34;: loadIcon(\u0026#34;down.png\u0026#34;), } } // Icon 被多个goroutine调用时不是并发安全的 func Icon(name string) image.Image { if icons == nil { loadIcons() } return icons[name] } 多个 goroutine 并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个 goroutine 都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：\nfunc loadIcons() { icons = make(map[string]image.Image) icons[\u0026#34;left\u0026#34;] = loadIcon(\u0026#34;left.png\u0026#34;) icons[\u0026#34;up\u0026#34;] = loadIcon(\u0026#34;up.png\u0026#34;) icons[\u0026#34;right\u0026#34;] = loadIcon(\u0026#34;right.png\u0026#34;) icons[\u0026#34;down\u0026#34;] = loadIcon(\u0026#34;down.png\u0026#34;) } 在这种情况下就会出现即使判断了icons不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的 goroutine 操作，但是这样做又会引发性能问题。\n使用sync.Once改造的示例代码如下：\nvar icons map[string]image.Image var loadIconsOnce sync.Once func loadIcons() { icons = map[string]image.Image{ \u0026#34;left\u0026#34;: loadIcon(\u0026#34;left.png\u0026#34;), \u0026#34;up\u0026#34;: loadIcon(\u0026#34;up.png\u0026#34;), \u0026#34;right\u0026#34;: loadIcon(\u0026#34;right.png\u0026#34;), \u0026#34;down\u0026#34;: loadIcon(\u0026#34;down.png\u0026#34;), } } // Icon 是并发安全的 func Icon(name string) image.Image { loadIconsOnce.Do(loadIcons) return icons[name] } 6.4.2 并发安全的单例模式 下面是借助sync.Once实现的并发安全的单例模式：\npackage singleton import ( \u0026#34;sync\u0026#34; ) type singleton struct {} var instance *singleton var once sync.Once func GetInstance() *singleton { once.Do(func() { instance = \u0026amp;singleton{} }) return instance } sync.Once其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。\n6.5 sync.Map Go 语言中内置的 map 不是并发安全的，请看下面这段示例代码。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;sync\u0026#34; ) var m = make(map[string]int) func get(key string) int { return m[key] } func set(key string, value int) { m[key] = value } func main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\u0026#34;k=:%v,v:=%v\\n\u0026#34;, key, get(key)) wg.Done() }(i) } wg.Wait() } 将上面的代码编译后执行，会报出fatal error: concurrent map writes错误。我们不能在多个 goroutine 中并发对内置的 map 进行读写操作，否则会存在数据竞争问题。\n像这种场景下就需要为 map 加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版 map——sync.Map。开箱即用表示其不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。\n方法名 功能 func (m *Map) Store(key, value interface{}) 存储key-value数据 func (m *Map) Load(key interface{}) (value interface{}, ok bool) 查询key对应的value func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) 查询或存储key对应的value func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) 查询并删除key func (m *Map) Delete(key interface{}) 删除key func (m *Map) Range(f func(key, value interface{}) bool) 对map中的每个key-value依次调用f 下面的代码示例演示了并发读写sync.Map。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;sync\u0026#34; ) // 并发安全的map var m = sync.Map{} func main() { wg := sync.WaitGroup{} // 对m执行20个并发的读写操作 for i := 0; i \u0026lt; 20; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) m.Store(key, n) // 存储key-value value, _ := m.Load(key) // 根据key取值 fmt.Printf(\u0026#34;k=:%v,v:=%v\\n\u0026#34;, key, value) wg.Done() }(i) } wg.Wait() } 7.原子操作 针对整数数据类型（int32、uint32、int64、uint64）我们还可以使用原子操作来保证并发安全，通常直接使用原子操作比使用锁操作效率更高。Go语言中原子操作由内置的标准库sync/atomic提供。\n7.1 atomic包 方法 解释 func LoadInt32(addr *int32) (val int32)func LoadInt64(addr *int64) (val int64)func LoadUint32(addr *uint32) (val uint32)func LoadUint64(addr *uint64) (val uint64)func LoadUintptr(addr *uintptr) (val uintptr)func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) 读取操作 func StoreInt32(addr *int32, val int32)func StoreInt64(addr *int64, val int64)func StoreUint32(addr *uint32, val uint32)func StoreUint64(addr *uint64, val uint64)func StoreUintptr(addr *uintptr, val uintptr)func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) 写入操作 func AddInt32(addr *int32, delta int32) (new int32)func AddInt64(addr *int64, delta int64) (new int64)func AddUint32(addr *uint32, delta uint32) (new uint32)func AddUint64(addr *uint64, delta uint64) (new uint64)func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) 修改操作 func SwapInt32(addr *int32, new int32) (old int32)func SwapInt64(addr *int64, new int64) (old int64)func SwapUint32(addr *uint32, new uint32) (old uint32)func SwapUint64(addr *uint64, new uint64) (old uint64)func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) 交换操作 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) 比较并交换操作 7.2 示例 我们填写一个示例来比较下互斥锁和原子操作的性能。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; ) type Counter interface { Inc() Load() int64 } // 普通版 type CommonCounter struct { counter int64 } func (c CommonCounter) Inc() { c.counter++ } func (c CommonCounter) Load() int64 { return c.counter } // 互斥锁版 type MutexCounter struct { counter int64 lock sync.Mutex } func (m *MutexCounter) Inc() { m.lock.Lock() defer m.lock.Unlock() m.counter++ } func (m *MutexCounter) Load() int64 { m.lock.Lock() defer m.lock.Unlock() return m.counter } // 原子操作版 type AtomicCounter struct { counter int64 } func (a *AtomicCounter) Inc() { atomic.AddInt64(\u0026amp;a.counter, 1) } func (a *AtomicCounter) Load() int64 { return atomic.LoadInt64(\u0026amp;a.counter) } func test(c Counter) { var wg sync.WaitGroup start := time.Now() for i := 0; i \u0026lt; 1000; i++ { wg.Add(1) go func() { c.Inc() wg.Done() }() } wg.Wait() end := time.Now() fmt.Println(c.Load(), end.Sub(start)) } func main() { c1 := CommonCounter{} // 非并发安全 test(c1) c2 := MutexCounter{} // 使用互斥锁实现并发安全 test(\u0026amp;c2) c3 := AtomicCounter{} // 并发安全且比互斥锁效率更高 test(\u0026amp;c3) } atomic包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者 sync 包的函数/类型实现同步更好。\n练习题 使用 goroutine 和 channel 实现一个计算int64随机数各位数和的程序，例如生成随机数61345，计算其每个位数上的数字之和为19。 开启一个 goroutine 循环生成int64类型的随机数，发送到jobChan 开启24个 goroutine 从jobChan中取出随机数计算各位数的和，将结果发送到resultChan 主 goroutine 从resultChan取出结果并打印到终端输出 ","permalink":"https://N3bu74.github.io/posts/tech/golang_concurrency/","summary":"并发编程在当前软件领域是一个非常重要的概念，随着CPU等硬件的发展，我们无一例外的想让我们的程序运行的快一点、再快一点。Go语言在语言层面天生支持并发，充分利用现代CPU的多核优势，这也是Go语言能够大范围流行的一个很重要的原因。 1.基本概念 首先我们先来了解几个与并发编程相关的基","title":"Golang 并发"},{"content":"本文介绍了Go语言反射的意义和基本使用。\n1.变量的内在机制 Go语言中的变量是分为两部分的:\n类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 2.断言 Assertion 把一个接口类型指定为它原始的类型\nv.(type) // 或取 接口类型变量v 的原始类型 v.(User) // 原始类型为User的接口类型变量v，指定其为User类型\n例子：\npackage main import \u0026#34;fmt\u0026#34; type User struct { Name string Age int Sex bool } type Student struct { Class string User } func (u User) Sayname(name string) { fmt.Println(\u0026#34;我的名字叫做\u0026#34;, name) } // 断言 ： 返回 接口类型的原始类型 func main() { s := Student{\u0026#34;三年二班\u0026#34;,User{}} u := User{ Name: \u0026#34;Nebula\u0026#34;, Age: 18, Sex: true, } check(u) check(s) } func check(v interface{}) { switch v.(type) { case User: v.(User).Sayname(v.(User).Name) fmt.Println(\u0026#34;我是User\u0026#34;) case Student: v.(Student).Sayname(v.(Student).Name) fmt.Println(\u0026#34;我是Student\u0026#34;) } } 3.反射介绍 反射是指在程序运行期间对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。\n支持反射的语言可以在程序编译期间将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期间获取类型的反射信息，并且有能力修改它们。\nGo程序在运行期间使用reflect包访问程序的反射信息。\n在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。\n4.reflect包 在Go语言的反射机制中，任何接口值都由是一个具体类型和具体类型的值两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type。\n4.1 TypeOf 在Go语言中，使用reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func reflectType(x interface{}) { v := reflect.TypeOf(x) fmt.Printf(\u0026#34;type:%v\\n\u0026#34;, v) } func main() { var a float32 = 3.14 reflectType(a) // type:float32 var b int64 = 100 reflectType(b) // type:int64 } 4.1.1 type name和type kind 在反射中关于类型还划分为两种：类型（Type）和种类（Kind）。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到种类（Kind）。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type myInt int64 func reflectType(x interface{}) { t := reflect.TypeOf(x) fmt.Printf(\u0026#34;type:%v kind:%v\\n\u0026#34;, t.Name(), t.Kind()) } func main() { var a *float32 // 指针 var b myInt // 自定义类型 var c rune // 类型别名 reflectType(a) // type: kind:ptr reflectType(b) // type:myInt kind:int64 reflectType(c) // type:int32 kind:int32 type person struct { name string age int } type book struct{ title string } var d = person{ name: \u0026#34;沙河小王子\u0026#34;, age: 18, } var e = book{title: \u0026#34;《跟小王子学Go语言》\u0026#34;} reflectType(d) // type:person kind:struct reflectType(e) // type:book kind:struct } Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。\n在reflect包中定义的Kind类型如下：\ntype Kind uint const ( Invalid Kind = iota // 非法类型 Bool // 布尔型 Int // 有符号整型 Int8 // 有符号8位整型 Int16 // 有符号16位整型 Int32 // 有符号32位整型 Int64 // 有符号64位整型 Uint // 无符号整型 Uint8 // 无符号8位整型 Uint16 // 无符号16位整型 Uint32 // 无符号32位整型 Uint64 // 无符号64位整型 Uintptr // 指针 Float32 // 单精度浮点数 Float64 // 双精度浮点数 Complex64 // 64位复数类型 Complex128 // 128位复数类型 Array // 数组 Chan // 通道 Func // 函数 Interface // 接口 Map // 映射 Ptr // 指针 Slice // 切片 String // 字符串 Struct // 结构体 UnsafePointer // 底层指针 ) 4.2 ValueOf reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。\nreflect.Value类型提供的获取原始值的方法如下：\n方法 说明 Interface() interface {} 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型 Int() int64 将值以 int 类型返回，所有有符号整型均可以此方式返回 Uint() uint64 将值以 uint 类型返回，所有无符号整型均可以此方式返回 Float() float64 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 Bool() bool 将值以 bool 类型返回 Bytes() []bytes 将值以字节数组 []bytes 类型返回 String() string 将值以字符串类型返回 4.2.1 通过反射获取值 func reflectValue(x interface{}) { v := reflect.ValueOf(x) k := v.Kind() switch k { case reflect.Int64: // v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换 fmt.Printf(\u0026#34;type is int64, value is %d\\n\u0026#34;, int64(v.Int())) case reflect.Float32: // v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换 fmt.Printf(\u0026#34;type is float32, value is %f\\n\u0026#34;, float32(v.Float())) case reflect.Float64: // v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换 fmt.Printf(\u0026#34;type is float64, value is %f\\n\u0026#34;, float64(v.Float())) } } func main() { var a float32 = 3.14 var b int64 = 100 reflectValue(a) // type is float32, value is 3.140000 reflectValue(b) // type is int64, value is 100 // 将int类型的原始值转换为reflect.Value类型 c := reflect.ValueOf(10) fmt.Printf(\u0026#34;type c :%T\\n\u0026#34;, c) // type c :reflect.Value } 4.2.2通过反射设置变量的值 想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的Elem()方法来获取指针对应的值。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func reflectSetValue1(x interface{}) { v := reflect.ValueOf(x) if v.Kind() == reflect.Int64 { v.SetInt(200) //修改的是副本，reflect包会引发panic } } func reflectSetValue2(x interface{}) { v := reflect.ValueOf(x) // 反射中使用 Elem()方法获取指针对应的值 if v.Elem().Kind() == reflect.Int64 { v.Elem().SetInt(200) } } func main() { var a int64 = 100 // reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value reflectSetValue2(\u0026amp;a) fmt.Println(a) } 4.2.3 isNil()和isValid() 4.2.3.1 isNil() func (v Value) IsNil() bool IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。\n4.2.3.2 isValid() func (v Value) IsValid() bool IsValid()返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。\n4.2.3.3 举个例子 IsNil()常被用于判断指针是否为空；IsValid()常被用于判定返回值是否有效。\nfunc main() { // *int类型空指针 var a *int fmt.Println(\u0026#34;var a *int IsNil:\u0026#34;, reflect.ValueOf(a).IsNil()) // nil值 fmt.Println(\u0026#34;nil IsValid:\u0026#34;, reflect.ValueOf(nil).IsValid()) // 实例化一个匿名结构体 b := struct{}{} // 尝试从结构体中查找\u0026#34;abc\u0026#34;字段 fmt.Println(\u0026#34;不存在的结构体成员:\u0026#34;, reflect.ValueOf(b).FieldByName(\u0026#34;abc\u0026#34;).IsValid()) // 尝试从结构体中查找\u0026#34;abc\u0026#34;方法 fmt.Println(\u0026#34;不存在的结构体方法:\u0026#34;, reflect.ValueOf(b).MethodByName(\u0026#34;abc\u0026#34;).IsValid()) // map c := map[string]int{} // 尝试从map中查找一个不存在的键 fmt.Println(\u0026#34;map中不存在的键：\u0026#34;, reflect.ValueOf(c).MapIndex(reflect.ValueOf(\u0026#34;娜扎\u0026#34;)).IsValid()) } 5.结构体反射 5.1 与结构体相关的方法 任意值通过reflect.TypeOf()获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的NumField()和Field()方法获得结构体成员的详细信息。\nreflect.Type中与获取结构体成员相关的的方法如下表所示。\n方法 说明 Field(i int) StructField 根据索引，返回索引对应的结构体字段的信息。 NumField() int 返回结构体成员字段数量。 FieldByName(name string) (StructField, bool) 根据给定字符串返回字符串对应的结构体字段的信息。 FieldByIndex(index []int) StructField 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。 FieldByNameFunc(match func(string) bool) (StructField,bool) 根据传入的匹配函数匹配需要的字段。 NumMethod() int 返回该类型的方法集中方法的数目 Method(int) Method 返回该类型方法集中的第i个方法 MethodByName(string)(Method, bool) 根据方法名返回该类型方法集中的方法 5.2 StructField类型 StructField类型用来描述结构体中的一个字段的信息。\nStructField的定义如下：\ntype StructField struct { // Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为\u0026#34;\u0026#34;。 // 参见http://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // 字段的类型 Tag StructTag // 字段的标签 Offset uintptr // 字段在结构体中的字节偏移量 Index []int // 用于Type.FieldByIndex时的索引切片 Anonymous bool // 是否匿名字段 } 5.3 结构体反射示例 当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。\ntype student struct { Name string `json:\u0026#34;name\u0026#34;` Score int `json:\u0026#34;score\u0026#34;` } func main() { stu1 := student{ Name: \u0026#34;小王子\u0026#34;, Score: 90, } t := reflect.TypeOf(stu1) fmt.Println(t.Name(), t.Kind()) // student struct // 通过for循环遍历结构体的所有字段信息 for i := 0; i \u0026lt; t.NumField(); i++ { field := t.Field(i) fmt.Printf(\u0026#34;name:%s index:%d type:%v json tag:%v\\n\u0026#34;, field.Name, field.Index, field.Type, field.Tag.Get(\u0026#34;json\u0026#34;)) } // 通过字段名获取指定结构体字段信息 if scoreField, ok := t.FieldByName(\u0026#34;Score\u0026#34;); ok { fmt.Printf(\u0026#34;name:%s index:%d type:%v json tag:%v\\n\u0026#34;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(\u0026#34;json\u0026#34;)) } } 接下来编写一个函数printMethod(s interface{})来遍历打印s包含的方法。\n// 给student添加两个方法 Study和Sleep(注意首字母大写) func (s student) Study() string { msg := \u0026#34;好好学习，天天向上。\u0026#34; fmt.Println(msg) return msg } func (s student) Sleep() string { msg := \u0026#34;好好睡觉，快快长大。\u0026#34; fmt.Println(msg) return msg } func printMethod(x interface{}) { t := reflect.TypeOf(x) v := reflect.ValueOf(x) fmt.Println(t.NumMethod()) for i := 0; i \u0026lt; v.NumMethod(); i++ { methodType := v.Method(i).Type() fmt.Printf(\u0026#34;method name:%s\\n\u0026#34;, t.Method(i).Name) fmt.Printf(\u0026#34;method:%s\\n\u0026#34;, methodType) // 通过反射调用方法传递的参数必须是 []reflect.Value 类型 var args = []reflect.Value{} v.Method(i).Call(args) } } 6.反射是把双刃剑 反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。\n基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。 大量使用反射的代码通常难以理解。 反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。 7.练习题 编写代码利用反射实现一个ini文件的解析器程序。 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; ) type Student struct { Name string `ini:\u0026#34;name\u0026#34;` Age int `ini:\u0026#34;age\u0026#34;` } func main() { var m, err = iniToMap(\u0026#34;./a.ini\u0026#34;) if err != nil { fmt.Println(err.Error()) return } var student = Student{} parseConf(\u0026amp;student, m) fmt.Println(student) } // 解析map到结构体 func parseConf(i interface{}, m map[string]string) { v := reflect.ValueOf(i) k := reflect.TypeOf(i) for s := 0; s \u0026lt; v.Elem().NumField(); s++ { if tagValue, ok := m[k.Elem().Field(s).Tag.Get(\u0026#34;ini\u0026#34;)] ; ok{ switch k.Elem().Field(s).Type.Kind() { case reflect.Int: num, _ := strconv.Atoi(tagValue) v.Elem().Field(s).SetInt(int64(num)) case reflect.String: v.Elem().Field(s).SetString(tagValue) } } } } // ini配置读取到map中 func iniToMap(path string) (map[string]string, error) { var m = map[string]string{} fi, err := os.Open(path) if err != nil { return m, err } defer fi.Close() br := bufio.NewReader(fi) for { line, _, err := br.ReadLine() if err == io.EOF { break } var kv = strings.Split(string(line), \u0026#34;:\u0026#34;) if len(kv) \u0026gt;= 2 { m[kv[0]] = kv[1] } } return m, nil } ","permalink":"https://N3bu74.github.io/posts/tech/golang_reflect_assert/","summary":"本文介绍了Go语言反射的意义和基本使用。 1.变量的内在机制 Go语言中的变量是分为两部分的: 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 2.断言 Assertion 把一个接口类型指定为它原始的类型 v.(type) // 或取 接口类型变量v 的原始类型 v.(User) // 原始类型为User的接口类型变量v，指定其为U","title":"Golang 反射与断言"},{"content":"Go 语言中的错误处理与其他语言不太一样，它把错误当成一种值来处理，更强调判断错误、处理错误，而不是一股脑的 catch 捕获异常。\n1.Error 接口 Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用try/catch捕获异常的方式。\n1.1 Error 接口 Go 语言中使用一个名为 error 接口来表示错误类型。\ntype error interface { Error() string } error 接口只包含一个方法——Error，这个函数需要返回一个描述错误信息的字符串。\n当一个函数或方法需要返回错误时，我们通常是把错误作为最后一个返回值。例如下面标准库 os 中打开文件的函数。\nfunc Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } 由于 error 是一个接口类型，默认零值为nil。所以我们通常将调用函数返回的错误与nil进行比较，以此来判断函数是否返回错误。例如你会经常看到类似下面的错误判断代码。\nfile, err := os.Open(\u0026#34;./xx.go\u0026#34;) if err != nil { fmt.Println(\u0026#34;打开文件失败,err:\u0026#34;, err) return } 注意\n当我们使用fmt包打印错误时会自动调用 error 类型的 Error 方法，也就是会打印出错误的描述信息。\n1.2 创建错误 我们可以根据需求自定义 error，最简单的方式是使用errors 包提供的New函数创建一个错误。\n1.2.1 errors.New 函数签名如下，\nfunc New(text string) error 它接收一个字符串参数返回包含该字符串的错误。我们可以在函数返回时快速创建一个错误。\nfunc queryById(id int64) (*Info, error) { if id \u0026lt;= 0 { return nil, errors.New(\u0026#34;无效的id\u0026#34;) } // ... } 或者用来定义一个错误变量，例如标准库io.EOF错误定义如下。\nvar EOF = errors.New(\u0026#34;EOF\u0026#34;) 1.3 fmt.Errorf 当我们需要传入格式化的错误描述信息时，使用fmt.Errorf是个更好的选择。\nfmt.Errorf(\u0026#34;查询数据库失败，err:%v\u0026#34;, err) 但是上面的方式会丢失原有的错误类型，只拿到错误描述的文本信息。\n为了不丢失函数调用的错误链，使用fmt.Errorf时搭配使用特殊的格式化动词%w，可以实现基于已有的错误再包装得到一个新的错误。\nfmt.Errorf(\u0026#34;查询数据库失败，err:%w\u0026#34;, err) 对于这种二次包装的错误，errors包中提供了以下三个方法。\nfunc Unwrap(err error) error // 获得err包含下一层错误 func Is(err, target error) bool // 判断err是否包含target func As(err error, target interface{}) bool // 判断err是否为target类型 1.4 错误结构体类型 此外我们还可以自己定义结构体类型，实现``error`接口。\n// OpError 自定义结构体类型 type OpError struct { Op string } // Error OpError 类型实现error接口 func (e *OpError) Error() string { return fmt.Sprintf(\u0026#34;无权执行%s操作\u0026#34;, e.Op) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_error/","summary":"Go 语言中的错误处理与其他语言不太一样，它把错误当成一种值来处理，更强调判断错误、处理错误，而不是一股脑的 catch 捕获异常。 1.Error 接口 Go 语言中把错误当成一种特殊的值来处理，不支持其他语言中使用try/catch捕获异常的方式。 1.1 Error 接口 Go 语言中使用一个名为 error 接口来表示错误类型。 type error interface { Error() string } error","title":"Golang 错误处理"},{"content":"接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。\n本章学习目标\n了解为什么需要接口以及接口的特点 掌握接口的声明和使用 掌握接口值的概念 掌握空接口的特点及其使用场景 在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于之前章节中讲到的那些具体类型（字符串、切片、结构体等）更注重“我是谁”，接口类型更注重“我能做什么”的问题。接口类型就像是一种约定——概括了一种类型应该具备哪些方法，在Go语言中提倡使用面向接口的编程方式实现解耦。\n1.接口类型 接口是一种由程序员来定义的类型，一个接口类型就是一组方法的集合，它规定了需要实现的所有方法。\n相较于使用结构体类型，当我们使用接口类型说明相比于它是什么更关心它能做什么。\n1.1 接口的定义 每个接口类型由任意个方法签名组成，接口的定义格式如下：\ntype 接口类型名 interface{ 方法名1( 参数列表1 ) 返回值列表1 方法名2( 参数列表2 ) 返回值列表2 … } 其中：\n接口类型名：Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有关闭操作的接口叫closer等。接口名最好要能突出该接口的类型含义。 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。 举个例子，定义一个包含Write方法的Writer接口。\ntype Writer interface{ Write([]byte) error } 当你看到一个Writer接口类型的值时，你不知道它是什么，唯一知道的就是可以通过调用它的Write方法来做一些事情。\n1.2 实现接口的条件 接口就是规定了一个需要实现的方法列表，在 Go 语言中一个类型只要实现了接口中规定的所有方法，那么我们就称它实现了这个接口。\n我们定义的Singer接口类型，它包含一个Sing方法。\n// Singer 接口 type Singer interface { Sing() } 我们有一个Bird结构体类型如下。\ntype Bird struct {} 因为Singer接口只包含一个Sing方法，所以只需要给Bird结构体添加一个Sing方法就可以满足Singer接口的要求。\n// Sing Bird类型的Sing方法 func (b Bird) Sing() { fmt.Println(\u0026#34;汪汪汪\u0026#34;) } 这样就称为Bird实现了Singer接口。\n1.3 为什么要使用接口？ 现在假设我们的代码世界里有很多小动物，下面的代码片段定义了猫和狗，它们饿了都会叫。\npackage main import \u0026#34;fmt\u0026#34; type Cat struct{} func (c Cat) Say() { fmt.Println(\u0026#34;喵喵喵~\u0026#34;) } type Dog struct{} func (d Dog) Say() { fmt.Println(\u0026#34;汪汪汪~\u0026#34;) } func main() { c := Cat{} c.Say() d := Dog{} d.Say() } 这个时候又跑来了一只羊，羊饿了也会发出叫声。\ntype Sheep struct{} func (s Sheep) Say() { fmt.Println(\u0026#34;咩咩咩~\u0026#34;) } 我们接下来定义一个饿肚子的场景。\n// MakeCatHungry 猫饿了会喵喵喵~ func MakeCatHungry(c Cat) { c.Say() } // MakeSheepHungry 羊饿了会咩咩咩~ func MakeSheepHungry(s Sheep) { s.Say() } 接下来会有越来越多的小动物跑过来，我们的代码世界该怎么拓展呢？\n在饿肚子这个场景下，我们可不可以把所有动物都当成一个“会叫的类型”来处理呢？当然可以！使用接口类型就可以实现这个目标。 我们的代码其实并不关心究竟是什么动物在叫，我们只是在代码中调用它的Say()方法，这就足够了。\n我们可以约定一个Sayer类型，它必须实现一个Say()方法，只要饿肚子了，我们就调用Say()方法。\ntype Sayer interface { Say() } 然后我们定义一个通用的MakeHungry函数，接收Sayer类型的参数。\n// MakeHungry 饿肚子了... func MakeHungry(s Sayer) { s.Say() } 我们通过使用接口类型，把所有会叫的动物当成Sayer类型来处理，只要实现了Say()方法都能当成Sayer类型的变量来处理。\nvar c cat MakeHungry(c) var d dog MakeHungry(d) 在电商系统中我们允许用户使用多种支付方式（支付宝支付、微信支付、银联支付等），我们的交易流程中可能不太在乎用户究竟使用什么支付方式，只要它能提供一个实现支付功能的Pay方法让调用方调用就可以了。\n再比如我们需要在某个程序中添加一个将某些指标数据向外输出的功能，根据不同的需求可能要将数据输出到终端、写入到文件或者通过网络连接发送出去。在这个场景下我们可以不关注最终输出的目的地是什么，只需要它能提供一个Write方法让我们把内容写入就可以了。\nGo语言中为了解决类似上面的问题引入了接口的概念，接口类型区别于我们之前章节中介绍的那些具体类型，让我们专注于该类型提供的方法，而不是类型本身。使用接口类型通常能够让我们写出更加通用和灵活的代码。\n1.4 面向接口编程 PHP、Java等语言中也有接口的概念，不过在PHP和Java语言中需要显式声明一个类实现了哪些接口，在Go语言中使用隐式声明的方式实现接口。只要一个类型实现了接口中规定的所有方法，那么它就实现了这个接口。\nGo语言中的这种设计符合程序开发中抽象的一般规律，例如在下面的代码示例中，我们的电商系统最开始只设计了支付宝一种支付方式：\ntype ZhiFuBao struct { // 支付宝 } // Pay 支付宝的支付方法 func (z *ZhiFuBao) Pay(amount int64) { fmt.Printf(\u0026#34;使用支付宝付款：%.2f元。\\n\u0026#34;, float64(amount/100)) } // Checkout 结账 func Checkout(obj *ZhiFuBao) { // 支付100元 obj.Pay(100) } func main() { Checkout(\u0026amp;ZhiFuBao{}) } 随着业务的发展，根据用户需求添加支持微信支付。\ntype WeChat struct { // 微信 } // Pay 微信的支付方法 func (w *WeChat) Pay(amount int64) { fmt.Printf(\u0026#34;使用微信付款：%.2f元。\\n\u0026#34;, float64(amount/100)) } 在实际的交易流程中，我们可以根据用户选择的支付方式来决定最终调用支付宝的Pay方法还是微信支付的Pay方法。\n// Checkout 支付宝结账 func CheckoutWithZFB(obj *ZhiFuBao) { // 支付100元 obj.Pay(100) } // Checkout 微信支付结账 func CheckoutWithWX(obj *WeChat) { // 支付100元 obj.Pay(100) } 实际上，从上面的代码示例中我们可以看出，我们其实并不怎么关心用户选择的是什么支付方式，我们只关心调用Pay方法时能否正常运行。这就是典型的“不关心它是什么，只关心它能做什么”的场景。\n在这种场景下我们可以将具体的支付方式抽象为一个名为Payer的接口类型，即任何实现了Pay方法的都可以称为Payer类型。\n// Payer 包含支付方法的接口类型 type Payer interface { Pay(int64) } 此时只需要修改下原始的Checkout函数，它接收一个Payer类型的参数。这样就能够在不修改既有函数调用的基础上，支持新的支付方式。\n// Checkout 结账 func Checkout(obj Payer) { // 支付100元 obj.Pay(100) } func main() { Checkout(\u0026amp;ZhiFuBao{}) // 之前调用支付宝支付 Checkout(\u0026amp;WeChat{}) // 现在支持使用微信支付 } 像类似的例子在我们编程过程中会经常遇到：\n比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？ 比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？ 比如满减券、立减券、打折券都属于电商场景下常见的优惠方式，我们能不能把它们当成“优惠券”来处理呢？ 接口类型是Go语言提供的一种工具，在实际的编码过程中是否使用它由你自己决定，但是通常使用接口类型可以使代码更清晰易读。\n1.5 接口类型变量 那实现了接口又有什么用呢？一个接口类型的变量能够存储所有实现了该接口的类型变量。\n例如在上面的示例中，Dog和Cat类型均实现了Sayer接口，此时一个Sayer类型的变量就能够接收Cat和Dog类型的变量。\nvar x Sayer // 声明一个Sayer类型的变量x a := Cat{} // 声明一个Cat类型变量a b := Dog{} // 声明一个Dog类型变量b x = a // 可以把Cat类型变量直接赋值给x x.Say() // 喵喵喵 x = b // 可以把Dog类型变量直接赋值给x x.Say() // 汪汪汪 2.值接收者和指针接收者 在结构体那一章节中，我们介绍了在定义结构体方法时既可以使用值接收者也可以使用指针接收者。那么对于实现接口来说使用值接收者和使用指针接收者有什么区别呢？接下来我们通过一个例子看一下其中的区别。\n我们定义一个Mover接口，它包含一个Move方法。\n// Mover 定义一个接口类型 type Mover interface { Move() } 2.1 值接收者实现接口 我们定义一个Dog结构体类型，并使用值接收者为其定义一个Move方法。\n// Dog 狗结构体类型 type Dog struct{} // Move 使用值接收者定义Move方法实现Mover接口 func (d Dog) Move() { fmt.Println(\u0026#34;狗会动\u0026#34;) } 此时实现Mover接口的是Dog类型。\nvar x Mover // 声明一个Mover类型的变量x var d1 = Dog{} // d1是Dog类型 x = d1 // 可以将d1赋值给变量x x.Move() var d2 = \u0026amp;Dog{} // d2是Dog指针类型 x = d2 // 也可以将d2赋值给变量x x.Move() 从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。\n2.2 指针接收者实现接口 我们再来测试一下使用指针接收者实现接口有什么区别。\n// Cat 猫结构体类型 type Cat struct{} // Move 使用指针接收者定义Move方法实现Mover接口 func (c *Cat) Move() { fmt.Println(\u0026#34;猫会动\u0026#34;) } 此时实现Mover接口的是*Cat类型，我们可以将*Cat类型的变量直接赋值给Mover接口类型的变量x。\nvar c1 = \u0026amp;Cat{} // c1是*Cat类型 x = c1 // 可以将c1当成Mover类型 x.Move() 但是不能给将Cat类型的变量赋值给Mover接口类型的变量x。\n// 下面的代码无法通过编译 var c2 = Cat{} // c2是Cat类型 x = c2 // 不能将c2当成Mover类型 由于Go语言中有对指针求值的语法糖，对于值接收者实现的接口，无论使用值类型还是指针类型都没有问题。但是我们并不总是能对一个值求址，所以对于指针接收者实现的接口要额外注意。\n3.类型与接口的关系 3.1 一个类型实现多个接口 一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。例如狗不仅可以叫，还可以动。我们完全可以分别定义Sayer接口和Mover接口，具体代码示例如下。\n// Sayer 接口 type Sayer interface { Say() } // Mover 接口 type Mover interface { Move() } Dog既可以实现Sayer接口，也可以实现Mover接口。\ntype Dog struct { Name string } // 实现Sayer接口 func (d Dog) Say() { fmt.Printf(\u0026#34;%s会叫汪汪汪\\n\u0026#34;, d.Name) } // 实现Mover接口 func (d Dog) Move() { fmt.Printf(\u0026#34;%s会动\\n\u0026#34;, d.Name) } 同一个类型实现不同的接口互相不影响使用。\nvar d = Dog{Name: \u0026#34;旺财\u0026#34;} var s Sayer = d var m Mover = d s.Say() // 对Sayer类型调用Say方法 m.Move() // 对Mover类型调用Move方法 3.2 多种类型实现同一接口 Go语言中不同的类型还可以实现同一接口。例如在我们的代码世界中不仅狗可以动，汽车也可以动。我们可以使用如下代码体现这个关系。\n// 实现Mover接口 func (d Dog) Move() { fmt.Printf(\u0026#34;%s会动\\n\u0026#34;, d.Name) } // Car 汽车结构体类型 type Car struct { Brand string } // Move Car类型实现Mover接口 func (c Car) Move() { fmt.Printf(\u0026#34;%s速度70迈\\n\u0026#34;, c.Brand) } 这样我们在代码中就可以把狗和汽车当成一个会动的类型来处理，不必关注它们具体是什么，只需要调用它们的Move方法就可以了。\nvar obj Mover obj = Dog{Name: \u0026#34;旺财\u0026#34;} obj.Move() obj = Car{Brand: \u0026#34;宝马\u0026#34;} obj.Move() 上面的代码执行结果如下：\n旺财会跑 宝马速度70迈 一个接口的所有方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。\n// WashingMachine 洗衣机 type WashingMachine interface { wash() dry() } // 甩干器 type dryer struct{} // 实现WashingMachine接口的dry()方法 func (d dryer) dry() { fmt.Println(\u0026#34;甩一甩\u0026#34;) } // 海尔洗衣机 type haier struct { dryer //嵌入甩干器 } // 实现WashingMachine接口的wash()方法 func (h haier) wash() { fmt.Println(\u0026#34;洗刷刷\u0026#34;) } 4.接口组合 接口与接口之间可以通过互相嵌套形成新的接口类型，例如Go标准库io源码中就有很多接口之间互相组合的示例。\n// src/io/io.go type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } type Closer interface { Close() error } // ReadWriter 是组合Reader接口和Writer接口形成的新接口类型 type ReadWriter interface { Reader Writer } // ReadCloser 是组合Reader接口和Closer接口形成的新接口类型 type ReadCloser interface { Reader Closer } // WriteCloser 是组合Writer接口和Closer接口形成的新接口类型 type WriteCloser interface { Writer Closer } 对于这种由多个接口类型组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。\n接口也可以作为结构体的一个字段，我们来看一段Go标准库sort源码中的示例。\n// src/sort/sort.go // Interface 定义通过索引对元素排序的接口类型 type Interface interface { Len() int Less(i, j int) bool Swap(i, j int) } // reverse 结构体中嵌入了Interface接口 type reverse struct { Interface } 通过在结构体中嵌入一个接口类型，从而让该结构体类型实现了该接口类型，并且还可以改写该接口的方法。\n// Less 为reverse类型添加Less方法，重写原Interface接口类型的Less方法 func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } Interface类型原本的Less方法签名为Less(i, j int) bool，此处重写为r.Interface.Less(j, i)，即通过将索引参数交换位置实现反转。\n在这个示例中还有一个需要注意的地方是reverse结构体本身是不可导出的（结构体类型名称首字母小写），sort.go中通过定义一个可导出的Reverse函数来让使用者创建reverse结构体实例。\nfunc Reverse(data Interface) Interface { return \u0026amp;reverse{data} } 这样做的目的是保证得到的reverse结构体中的Interface属性一定不为nil，否者r.Interface.Less(j, i)就会出现空指针panic。\n此外在Go内置标准库database/sql中也有很多类似的结构体内嵌接口类型的使用示例，各位读者可自行查阅。\n5.空接口 5.1 空接口的定义 空接口是指没有定义任何方法的接口类型。因此任何类型都可以视为实现了空接口。也正是因为空接口类型的这个特性，空接口类型的变量可以存储任意类型的值。\npackage main import \u0026#34;fmt\u0026#34; // 空接口 // Any 不包含任何方法的空接口类型 type Any interface{} // Dog 狗结构体 type Dog struct{} func main() { var x Any x = \u0026#34;你好\u0026#34; // 字符串型 fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, x, x) x = 100 // int型 fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, x, x) x = true // 布尔型 fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, x, x) x = Dog{} // 结构体类型 fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, x, x) } 通常我们在使用空接口类型时不必使用type关键字声明，可以像下面的代码一样直接使用interface{}。\nvar x interface{} // 声明一个空接口类型变量x 5.2 空接口的应用 5.2.1 空接口作为函数的参数 使用空接口实现可以接收任意类型的函数参数。\n// 空接口作为函数参数 func show(a interface{}) { fmt.Printf(\u0026#34;type:%T value:%v\\n\u0026#34;, a, a) } 5.2.2 空接口作为map的值 使用空接口实现可以保存任意值的字典。\n// 空接口作为map值 var studentInfo = make(map[string]interface{}) studentInfo[\u0026#34;name\u0026#34;] = \u0026#34;沙河娜扎\u0026#34; studentInfo[\u0026#34;age\u0026#34;] = 18 studentInfo[\u0026#34;married\u0026#34;] = false fmt.Println(studentInfo) 6.接口值 由于接口类型的值可以是任意一个实现了该接口的类型值，所以接口值除了需要记录具体值之外，还需要记录这个值属于的类型。也就是说接口值由“类型”和“值”组成，鉴于这两部分会根据存入值的不同而发生变化，我们称之为接口的动态类型和动态值。\n我们接下来通过一个示例来加深对接口值的理解。\n下面的示例代码中，定义了一个Mover接口类型和两个实现了该接口的Dog和Car结构体类型。\ntype Mover interface { Move() } type Dog struct { Name string } func (d *Dog) Move() { fmt.Println(\u0026#34;狗在跑~\u0026#34;) } type Car struct { Brand string } func (c *Car) Move() { fmt.Println(\u0026#34;汽车在跑~\u0026#34;) } 首先，我们创建一个Mover接口类型的变量m。\nvar m Mover 此时，接口变量m是接口类型的零值，也就是它的类型和值部分都是nil，就如下图所示。\n我们可以使用m == nil来判断此时的接口值是否为空。\nfmt.Println(m == nil) // true **注意：**我们不能对一个空接口值调用任何方法，否则会产生panic。\nm.Move() // panic: runtime error: invalid memory address or nil pointer dereference 接下来，我们将一个*Dog结构体指针赋值给变量m。\nm = \u0026amp;Dog{Name: \u0026#34;旺财\u0026#34;} 此时，接口值m的动态类型会被设置为*Dog，动态值为结构体变量的拷贝。\n然后，我们给接口变量m赋值为一个*Car类型的值。\nvar c *Car m = c 这一次，接口值m的动态类型为*Car，动态值为nil。\n**注意：**此时接口变量m与nil并不相等，因为它只是动态值的部分为nil，而动态类型部分保存着对应值的类型。\nfmt.Println(m == nil) // false 接口值是支持相互比较的，当且仅当接口值的动态类型和动态值都相等时才相等。\nvar ( x Mover = new(Dog) y Mover = new(Car) ) fmt.Println(x == y) // false 但是有一种特殊情况需要特别注意，如果接口值保存的动态类型相同，但是这个动态类型不支持互相比较（比如切片），那么对它们相互比较时就会引发panic。\nvar z interface{} = []int{1, 2, 3} fmt.Println(z == z) // panic: runtime error: comparing uncomparable type []int 7.类型断言 接口值可能赋值为任意类型的值，那我们如何从接口值获取其存储的具体数据呢？\n我们可以借助标准库fmt包的格式化打印获取到接口值的动态类型。\nvar m Mover m = \u0026amp;Dog{Name: \u0026#34;旺财\u0026#34;} fmt.Printf(\u0026#34;%T\\n\u0026#34;, m) // *main.Dog m = new(Car) fmt.Printf(\u0026#34;%T\\n\u0026#34;, m) // *main.Car 而fmt包内部其实是使用反射的机制在程序运行时获取到动态类型的名称。关于反射的内容我们会在后续章节详细介绍。\n而想要从接口值中获取到对应的实际值需要使用类型断言，其语法格式如下。\nx.(T) 其中：\nx：表示接口类型的变量 T：表示断言x可能是的类型。 该语法返回两个参数，第一个参数是x转化为T类型后的变量，第二个值是一个布尔值，若为true则表示断言成功，为false则表示断言失败。\n举个例子：\nvar n Mover = \u0026amp;Dog{Name: \u0026#34;旺财\u0026#34;} v, ok := n.(*Dog) if ok { fmt.Println(\u0026#34;类型断言成功\u0026#34;) v.Name = \u0026#34;富贵\u0026#34; // 变量v是*Dog类型 } else { fmt.Println(\u0026#34;类型断言失败\u0026#34;) } 如果对一个接口值有多个实际类型需要判断，推荐使用switch语句来实现。\n// justifyType 对传入的空接口类型变量x进行类型断言 func justifyType(x interface{}) { switch v := x.(type) { case string: fmt.Printf(\u0026#34;x is a string，value is %v\\n\u0026#34;, v) case int: fmt.Printf(\u0026#34;x is a int is %v\\n\u0026#34;, v) case bool: fmt.Printf(\u0026#34;x is a bool is %v\\n\u0026#34;, v) default: fmt.Println(\u0026#34;unsupport type！\u0026#34;) } } 由于接口类型变量能够动态存储不同类型值的特点，所以很多初学者会滥用接口类型（特别是空接口）来实现编码过程中的便捷。只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。切记不要为了使用接口类型而增加不必要的抽象，导致不必要的运行时损耗。\n在 Go 语言中接口是一个非常重要的概念和特性，使用接口类型能够实现代码的抽象和解耦，也可以隐藏某个功能的内部实现，但是缺点就是在查看源码的时候，不太方便查找到具体实现接口的类型。\n相信很多读者在刚接触到接口类型时都会有很多疑惑，请牢记接口是一种类型，一种抽象的类型。区别于我们在之前章节提到的那些具体类型（整型、数组、结构体类型等），它是一个只要求实现特定方法的抽象类型。\n小技巧： 下面的代码可以在程序编译阶段验证某一结构体是否满足特定的接口类型。\n// 摘自gin框架routergroup.go type IRouter interface{ ... } type RouterGroup struct { ... } var _ IRouter = \u0026amp;RouterGroup{} // 确保RouterGroup实现了接口IRouter 上面的代码中也可以使用var _ IRouter = (*RouterGroup)(nil)进行验证。\n8.练习题 使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) // 接口 type Logger interface { consoleLog() // 终端 fileLog() // 文件 } // 用户结构体 type User struct { username string password string } // User实现方法 func (u User) consoleLog() { t := time.Now() fmt.Printf(\u0026#34;用户创建成功！用户名为：%s\u0026#34;, u.username) fmt.Printf(\u0026#34;用户密码是：%s\\n\u0026#34;, u.password) fmt.Printf(\u0026#34;创建完成时间：%d-%d-%d %d:%d:%d\\n\u0026#34;, t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second()) } func (u User) fileLog() { t := time.Now() file, err := os.OpenFile(\u0026#34;./\u0026#34;+u.username+\u0026#34;.txt\u0026#34;, os.O_RDWR|os.O_CREATE, 0766) if err != nil { fmt.Println(err) } data := \u0026#34;用户创建成功！ 用户名为：\u0026#34; + fmt.Sprintf(\u0026#34;%s\\n\u0026#34;, u.username) + \u0026#34;密码是：\u0026#34; + u.password + \u0026#34;\\n\u0026#34; + fmt.Sprintf(\u0026#34;创建完成时间：%d-%d-%d %d:%d:%d\\n\u0026#34;, t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second()) _, _ = file.WriteString(data) _ = file.Close() } // User中的字段初始化 func newUser(username, password string) User { return User{ username: username, password: password, } } // 创建用户对象 func createUser() { var ( username string password string ) fmt.Print(\u0026#34;请输入用户名：\u0026#34;) _, err := fmt.Scan(\u0026amp;username) fmt.Print(\u0026#34;请输入一个密码：\u0026#34;) _, err = fmt.Scan(\u0026amp;password) if err != nil { fmt.Println(\u0026#34;输入错误！！ERROR:\u0026#34;, err) } u := newUser(username, password) u.consoleLog() u.fileLog() } // 主函数 func main() { createUser() } 生成的文件是放在根目录下的也就是$GOPATH/src 目录下的\n","permalink":"https://N3bu74.github.io/posts/tech/golang_interface/","summary":"接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。 本章学习目标 了解为什么需要接口以及接口的特点 掌握接口的声明和使用 掌握接口值的概念 掌握空接口的特点及其使用场景 在Go语言中接口（interface）是一种类型，一种抽象的类型。相较于","title":"Golang 接口"},{"content":"在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。\n本章学习目标\n掌握包的定义和使用 掌握init初始化函数的使用 掌握依赖管理工具go module的使用 在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何引入其他包。同时也将介绍如何在项目中使用go module管理依赖。\n1.包（package） 1.1 包介绍 Go语言中支持模块化的开发理念，在Go语言中使用包（package）来支持代码模块化和代码复用。一个包是由一个或多个Go源码文件（.go结尾的文件）组成，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如fmt、os、io等。\n例如，在之前的章节中我们频繁使用了fmt这个内置包。\npackage main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;Hello world!\u0026#34;) } 上面短短的几行代码就涉及到了如何定义包以及如何引入其它包两个内容，接下来我们依次介绍一下它们。\n1.2 定义包 我们可以根据自己的需要创建自定义包。一个包可以简单理解为一个存放.go文件的文件夹。该文件夹下面的所有.go文件都要在非注释的第一行添加如下声明，声明该文件归属的包。\npackage packagename 其中：\npackage：声明包的关键字 packagename：包名，可以不与文件夹的名称一致，不能包含 - 符号，最好与其实现的功能相对应。 另外需要注意一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。包名为main的包是应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。\n1.3 标识符可见性 在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如fmt.Println(\u0026quot;Hello world!\u0026quot;)，就是指调用fmt包中的Println函数。\n如果想让一个包中的标识符（如变量、常量、类型、函数等）能被外部的包使用，那么标识符必须是对外可见的（public）。在Go语言中是通过标识符的首字母大/小写来控制标识符的对外可见（public）/不可见（private）的。在一个包内部只有首字母大写的标识符才是对外可见的。\n例如我们定义一个名为demo的包，在其中定义了若干标识符。在另外一个包中并不是所有的标识符都能通过demo.前缀访问到，因为只有那些首字母是大写的标识符才是对外可见的。\npackage demo import \u0026#34;fmt\u0026#34; // 包级别标识符的可见性 // num 定义一个全局整型变量 // 首字母小写，对外不可见(只能在当前包内使用) var num = 100 // Mode 定义一个常量 // 首字母大写，对外可见(可在其它包中使用) const Mode = 1 // person 定义一个代表人的结构体 // 首字母小写，对外不可见(只能在当前包内使用) type person struct { name string Age int } // Add 返回两个整数和的函数 // 首字母大写，对外可见(可在其它包中使用) func Add(x, y int) int { return x + y } // sayHi 打招呼的函数 // 首字母小写，对外不可见(只能在当前包内使用) func sayHi() { var myName = \u0026#34;七米\u0026#34; // 函数局部变量，只能在当前函数内使用 fmt.Println(myName) } 同样的规则也适用于结构体，结构体中可导出字段的字段名称必须首字母大写。\ntype Student struct { Name string // 可在包外访问的方法 class string // 仅限包内访问的字段 } 1.4 包的引入 要在当前包中使用另外一个包的内容就需要使用import关键字引入这个包，并且import语句通常放在文件的开头，package声明语句的下方。完整的引入声明语句格式如下:\nimport importname \u0026#34;path/to/package\u0026#34; 其中：\nimportname：引入的包名，通常都省略。默认值为引入包的包名。 path/to/package：引入包的路径名称，必须使用双引号包裹起来。 Go语言中禁止循环导入包。 一个Go源码文件中可以同时引入多个包，例如：\nimport \u0026#34;fmt\u0026#34; import \u0026#34;net/http\u0026#34; import \u0026#34;os\u0026#34; 当然可以使用批量引入的方式。\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) 当引入的多个包中存在相同的包名或者想自行为某个引入的包设置一个新包名时，都需要通过importname指定一个在当前文件中使用的新包名。例如，在引入fmt包时为其指定一个新包名f。\nimport f \u0026#34;fmt\u0026#34; 这样在当前这个文件中就可以通过使用f来调用fmt包中的函数了。\nf.Println(\u0026#34;Hello world!\u0026#34;) 如果引入一个包的时候为其设置了一个特殊 _ 作为包名，那么这个包的引入方式就称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的init函数将被执行并且仅执行一遍。\nimport _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; 匿名引入的包与其他方式导入的包一样都会被编译到可执行文件中。\n需要注意的是，Go语言中不允许引入包却不在代码中使用这个包的内容，如果引入了未使用的包则会触发编译错误。\n1.5 init初始化函数 在每一个Go源文件中，都可以定义任意个如下格式的特殊函数：\nfunc init(){ // ... } 这种特殊的函数不接收任何参数也没有任何返回值，我们也不能在代码中主动调用它。当程序启动的时候，init函数会按照它们声明的顺序自动执行。\n一个包的初始化过程是按照代码中引入的顺序来进行的，所有在该包中声明的init函数都将被串行调用并且仅调用执行一次。每一个包初始化的时候都是先执行依赖的包中声明的init函数再执行当前包中声明的init函数。确保在程序的main函数开始执行时所有的依赖包都已初始化完成。\n每一个包的初始化是先从初始化包级别变量开始的。例如从下面的示例中我们就可以看出包级别变量的初始化会先于init初始化函数。\npackage main import \u0026#34;fmt\u0026#34; var x int8 = 10 const pi = 3.14 func init() { fmt.Println(\u0026#34;x:\u0026#34;, x) fmt.Println(\u0026#34;pi:\u0026#34;, pi) sayHi() } func sayHi() { fmt.Println(\u0026#34;Hello World!\u0026#34;) } func main() { fmt.Println(\u0026#34;你好，世界！\u0026#34;) } 输出结果：\nx: 10 pi: 3.14 Hello World! 你好，世界！ 在上面的代码中，我们了解了Go语言中包的定义及包的初始化过程，这让我们能够在开发时按照自己的需要定义包。同时我们还学到了如何在我们的代码中引入其它的包，不过在本小节的所有示例中我们都是引入Go内置的包。现代编程语言大多都允许开发者对外发布包/库，也支持开发者在自己的代码中引入第三方库。这样的设计能够让广大开发者一起参与到语言的生态环境建设当中，把生态建设的更加完善。\n2.go module 在Go语言的早期版本中，我们编写Go项目代码时所依赖的所有第三方包都需要保存在GOPATH这个目录下面。这样的依赖管理方式存在一个致命的缺陷，那就是不支持版本管理，同一个依赖包只能存在一个版本的代码。可是我们本地的多个项目完全可能分别依赖同一个第三方包的不同版本。\n2.1 go module介绍 Go module 是 Go1.11 版本发布的依赖管理方案，从 Go1.14 版本开始推荐在生产环境使用，于Go1.16版本默认开启。Go module 提供了以下命令供我们使用：\ngo module相关命令\n命令 介绍 go mod init 初始化项目依赖，生成go.mod文件 go mod download 根据go.mod文件下载依赖 go mod tidy 比对项目文件中引入的依赖与go.mod进行比对 go mod graph 输出依赖关系图 go mod edit 编辑go.mod文件 go mod vendor 将项目的所有依赖导出至vendor目录 go mod verify 检验一个依赖包是否被篡改过 go mod why 解释为什么需要某个依赖 Go语言在 go module 的过渡阶段提供了 GO111MODULE 这个环境变量来作为是否启用 go module 功能的开关，考虑到 Go1.16 之后 go module 已经默认开启，所以本书不再介绍该配置，对于刚接触Go语言的读者而言完全没有必要了解这个历史包袱。\nGOPROXY\n这个环境变量主要是用于设置 Go 模块代理（Go module proxy），其作用是用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。\nGOPROXY 的默认值是：https://proxy.golang.org,direct，由于某些原因国内无法正常访问该地址，所以我们通常需要配置一个可访问的地址。目前社区使用比较多的有两个https://goproxy.cn和https://goproxy.io，当然如果你的公司有提供GOPROXY地址那么就直接使用。设置GOPAROXY的命令如下：\ngo env -w GOPROXY=https://goproxy.cn,direct GOPROXY 允许设置多个代理地址，多个地址之间需使用英文逗号 “,” 分隔。最后的 “direct” 是一个特殊指示符，用于指示 Go 回源到源地址去抓取（比如 GitHub 等）。当配置有多个代理地址时，如果第一个代理地址返回 404 或 410 错误时，Go 会自动尝试下一个代理地址，当遇见 “direct” 时触发回源，也就是回到源地址去抓取。\nGOPRIVATE\n设置了GOPROXY 之后，go 命令就会从配置的代理地址拉取和校验依赖包。当我们在项目中引入了非公开的包（公司内部git仓库或 github 私有仓库等），此时便无法正常从代理拉取到这些非公开的依赖包，这个时候就需要配置 GOPRIVATE 环境变量。GOPRIVATE用来告诉 go 命令哪些仓库属于私有仓库，不必通过代理服务器拉取和校验。\nGOPRIVATE 的值也可以设置多个，多个地址之间使用英文逗号 “,” 分隔。我们通常会把自己公司内部的代码仓库设置到 GOPRIVATE 中，例如：\n$ go env -w GOPRIVATE=\u0026#34;git.mycompany.com\u0026#34; 这样在拉取以git.mycompany.com为路径前缀的依赖包时就能正常拉取了。\n此外，如果公司内部自建了 GOPROXY 服务，那么我们可以通过设置 GONOPROXY=none，允许通内部代理拉取私有仓库的包。\n2.2 使用go module引入包 接下来我们将通过一个示例来演示如何在开发项目时使用 go module 拉取和管理项目依赖。\n初始化项目 我们在本地新建一个名为holiday项目，按如下方式创建一个名为holiday的文件夹并切换到该目录下：\n$ mkdir holiday $ cd holiday 目前我们位于holiday文件夹下，接下来执行下面的命令初始化项目。\n$ go mod init holiday go: creating new go.mod: module holiday 该命令会自动在项目目录下创建一个go.mod文件，其内容如下。\nmodule holiday go 1.16 其中：\nmodule holiday：定义当前项目的导入路径 go 1.16：标识当前项目使用的 Go 版本 go.mod文件会记录项目使用的第三方依赖包信息，包括包名和版本，由于我们的holiday项目目前还没有使用到第三方依赖包，所以go.mod文件暂时还没有记录任何依赖包信息，只有当前项目的一些信息。\n接下来，我们在项目目录下新建一个main.go文件，其内容如下：\n// holiday/main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;现在是假期时间...\u0026#34;) } 然后，我们的holiday项目现在需要引入一个第三方包github.com/q1mi/hello来实现一些必要的功能。类似这样的场景在我们的日常开发中是很常见的。我们需要先将依赖包下载到本地同时在go.mod中记录依赖信息，然后才能在我们的代码中引入并使用这个包。下载依赖包主要有两种方法。\n第一种方法是在项目目录下执行go get命令手动下载依赖的包：\nholiday $ go get -u github.com/q1mi/hello go get: added github.com/q1mi/hello v0.1.1 这样默认会下载最新的发布版本，你也可以指定想要下载指定的版本号的。\nholiday $ go get -u github.com/q1mi/hello@v0.1.0 go: downloading github.com/q1mi/hello v0.1.0 go get: downgraded github.com/q1mi/hello v0.1.1 =\u0026gt; v0.1.0 如果依赖包没有发布任何版本则会拉取最新的提交，最终go.mod中的依赖信息会变成类似下面这种由默认v0.0.0的版本号和最新一次commit的时间和hash组成的版本格式：\nrequire github.com/q1mi/hello v0.0.0-20210218074646-139b0bcd549d 如果想指定下载某个commit对应的代码，可以直接指定commit hash，不过没有必要写出完整的commit hash，一般前7位即可。例如：\nholiday $ go get github.com/q1mi/hello@2ccfadd go: downloading github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3 go get: added github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3 此时，我们打开go.mod文件就可以看到下载的依赖包及版本信息都已经被记录下来了。\nmodule holiday go 1.16 require github.com/q1mi/hello v0.1.0 // indirect 行尾的indirect表示该依赖包为间接依赖，说明在当前程序中的所有 import 语句中没有发现引入这个包。\n另外在执行go get命令下载一个新的依赖包时一般会额外添加-u参数，强制更新现有依赖。\n第二种方式是我们直接编辑go.mod文件，将依赖包和版本信息写入该文件。例如我们修改holiday/go.mod文件内容如下：\nmodule holiday go 1.16 require github.com/q1mi/hello latest 表示当前项目需要使用github.com/q1mi/hello库的最新版本，然后在项目目录下执行go mod download下载依赖包。\nholiday $ go mod download 如果不输出其它提示信息就说明依赖已经下载成功，此时go.mod文件已经变成如下内容。\nmodule holiday go 1.16 require github.com/q1mi/hello v0.1.1 从中我们可以知道最新的版本号是v0.1.1。如果事先知道依赖包的具体版本号，可以直接在go.mod中指定需要的版本然后再执行go mod download下载。\n这种方法同样支持指定想要下载的commit进行下载，例如直接在go.mod文件中按如下方式指定commit hash，这里只写出来了commit hash的前7位。\nrequire github.com/q1mi/hello 2ccfadda 执行go mod download下载完依赖后，go.mod文件中对应的版本信息会自动更新为类似下面的格式。\nmodule holiday go 1.16 require github.com/q1mi/hello v0.1.2-0.20210219092711-2ccfaddad6a3 下载好要使用的依赖包之后，我们现在就可以在holiday/main.go文件中使用这个包了。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/q1mi/hello\u0026#34; ) func main() { fmt.Println(\u0026#34;现在是假期时间...\u0026#34;) hello.SayHi() // 调用hello包的SayHi函数 } 将上述代码编译执行，就能看到执行结果了。\nholiday $ go build holiday $ ./holiday 现在是假期时间... 你好，我是七米。很高兴认识你。 当我们的项目功能越做越多，代码越来越多的时候，通常会选择在项目内部按功能或业务划分成多个不同包。Go语言支持在一个项目（project）下定义多个包（package）。\n例如，我们在holiday项目内部创建一个新的package——summer，此时新的项目目录结构如下：\nholidy ├── go.mod ├── go.sum ├── main.go └── summer └── summer.go 其中holiday/summer/summer.go文件内容如下：\npackage summer import \u0026#34;fmt\u0026#34; // Diving 潜水... func Diving() { fmt.Println(\u0026#34;夏天去诗巴丹潜水...\u0026#34;) } 此时想要在当前项目目录下的其他包或者main.go中调用这个Diving函数需要如何引入呢？这里以在main.go中演示详细的调用过程为例，在项目内其他包的引入方式类似。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;holiday/summer\u0026#34; // 导入当前项目下的包 \u0026#34;github.com/q1mi/hello\u0026#34; // 导入github上第三方包 ) func main() { fmt.Println(\u0026#34;现在是假期时间...\u0026#34;) hello.SayHi() summer.Diving() } 从上面的示例可以看出，项目中定义的包都会以项目的导入路径为前缀。\n如果你想要导入本地的一个包，并且这个包也没有发布到到其他任何代码仓库，这时候你可以在go.mod文件中使用replace语句将依赖临时替换为本地的代码包。例如在我的电脑上有另外一个名为liwenzhou.com/overtime的项目，它位于holiday项目同级目录下：\n├── holiday │ ├── go.mod │ ├── go.sum │ ├── main.go │ └── summer │ └── summer.go └── overtime ├── go.mod └── overtime.go 由于liwenzhou.com/overtime包只存在于我本地，并不能通过网络获取到这个代码包，这个时候应该如何在holidy项目中引入它呢？\n我们可以在holidy/go.mod文件中正常引入liwenzhou.com/overtime包，然后像下面的示例那样使用replace语句将这个依赖替换为使用相对路径表示的本地包。\nmodule holiday go 1.16 require github.com/q1mi/hello v0.1.1 require liwenzhou.com/overtime v0.0.0 replace liwenzhou.com/overtime =\u0026gt; ../overtime 这样，我们就可以在holiday/main.go下正常引入并使用overtime包了。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;holiday/summer\u0026#34; // 导入当前项目下的包 \u0026#34;liwenzhou.com/overtime\u0026#34; // 通过replace导入的本地包 \u0026#34;github.com/q1mi/hello\u0026#34; // 导入github上第三方包 ) func main() { fmt.Println(\u0026#34;现在是假期时间...\u0026#34;) hello.SayHi() summer.Diving() overtime.Do() } 我们也经常使用replace将项目依赖中的某个包，替换为其他版本的代码包或我们自己修改后的代码包。\ngo.mod文件\ngo.mod文件中记录了当前项目中所有依赖包的相关信息，声明依赖的格式如下：\nrequire module/path v1.2.3 其中：\nrequire：声明依赖的关键字 module/path：依赖包的引入路径 v1.2.3：依赖包的版本号。支持以下几种格式： latest：最新版本 v1.0.0：详细版本号 commit hash：指定某次commit hash 引入某些没有发布过tag版本标识的依赖包时，go.mod中记录的依赖版本信息就会出现类似v0.0.0-20210218074646-139b0bcd549d的格式，由版本号、commit时间和commit的hash值组成。\ngo.sum文件\n使用go module下载了依赖后，项目目录下还会生成一个go.sum文件，这个文件中详细记录了当前项目中引入的依赖包的信息及其hash 值。go.sum文件内容通常是以类似下面的格式出现。\n\u0026lt;module\u0026gt; \u0026lt;version\u0026gt;/go.mod \u0026lt;hash\u0026gt; 或者\n\u0026lt;module\u0026gt; \u0026lt;version\u0026gt; \u0026lt;hash\u0026gt; \u0026lt;module\u0026gt; \u0026lt;version\u0026gt;/go.mod \u0026lt;hash\u0026gt; 不同于其他语言提供的基于中心的包管理机制，例如 npm 和 pypi等，Go并没有提供一个中央仓库来管理所有依赖包，而是采用分布式的方式来管理包。为了防止依赖包被非法篡改，Go module 引入了go.sum机制来对依赖包进行校验。\n依赖保存位置\nGo module 会把下载到本地的依赖包会以类似下面的形式保存在 $GOPATH/pkg/mod目录下，每个依赖包都会带有版本号进行区分，这样就允许在本地存在同一个包的多个不同版本。\nmod ├── cache ├── cloud.google.com ├── github.com └──q1mi ├── hello@v0.0.0-20210218074646-139b0bcd549d ├── hello@v0.1.1 └── hello@v0.1.0 ... 如果想清除所有本地已缓存的依赖包数据，可以执行 go clean -modcache 命令。\n2.3 使用go module发布包 在上面的小节中我们学习了如何在项目中引入别人提供的依赖包，那么当我们想要在社区发布一个自己编写的代码包或者在公司内部编写一个供内部使用的公用组件时，我们该怎么做呢？接下来，我们就一起编写一个代码包并将它发布到github.com仓库，让它能够被全球的Go语言开发者使用。\n我们首先在自己的 github 账号下新建一个项目，并把它下载到本地。我这里就以创建和发布一个名为hello的项目为例进行演示。这个hello包将对外提供一个名为SayHi的函数，它的作用非常简单就是向调用者发去问候。\n$ git clone https://github.com/q1mi/hello $ cd hello 我们当前位于hello项目目录下，执行下面的命令初始化项目，创建go.mod文件。需要注意的是这里定义项目的引入路径为github.com/q1mi/hello，读者在自行测试时需要将这部分替换为自己的仓库路径。\nhello $ go mod init github.com/q1mi/hello go: creating new go.mod: module github.com/q1mi/hello 接下来我们在该项目根目录下创建 hello.go 文件，添加下面的内容：\npackage hello import \u0026#34;fmt\u0026#34; func SayHi() { fmt.Println(\u0026#34;你好，我是七米。很高兴认识你。\u0026#34;) } 然后将该项目的代码 push 到仓库的远端分支，这样就对外发布了一个Go包。其他的开发者可以通过github.com/q1mi/hello这个引入路径下载并使用这个包了。\n一个设计完善的包应该包含开源许可证及文档等内容，并且我们还应该尽心维护并适时发布适当的版本。github 上发布版本号使用git tag为代码包打上标签即可。\nhello $ git tag -a v0.1.0 -m \u0026#34;release version v0.1.0\u0026#34; hello $ git push origin v0.1.0 经过上面的操作我们就发布了一个版本号为v0.1.0的版本。\nGo modules中建议使用语义化版本控制，其建议的版本号格式如下：\n其中：\n主版本号：发布了不兼容的版本迭代时递增（breaking changes）。 次版本号：发布了功能性更新时递增。 修订号：发布了bug修复类更新时递增。 发布新的主版本\n现在我们的hello项目要进行与之前版本不兼容的更新，我们计划让SayHi函数支持向指定人发出问候。更新后的SayHi函数内容如下：\npackage hello import \u0026#34;fmt\u0026#34; // SayHi 向指定人打招呼的函数 func SayHi(name string) { fmt.Printf(\u0026#34;你好%s，我是七米。很高兴认识你。\\n\u0026#34;, name) } 由于这次改动巨大（修改了函数之前的调用规则），对之前使用该包作为依赖的用户影响巨大。因此我们需要发布一个主版本号递增的v2版本。在这种情况下，我们通常会修改当前包的引入路径，像下面的示例一样为引入路径添加版本后缀。\n// hello/go.mod module github.com/q1mi/hello/v2 go 1.16 把修改后的代码提交：\nhello $ git add . hello $ git commit -m \u0026#34;feat: SayHi现在支持给指定人打招呼啦\u0026#34; hello $ git push 打好 tag 推送到远程仓库。\nhello $ git tag -a v2.0.0 -m \u0026#34;release version v2.0.0\u0026#34; hello $ git push origin v2.0.0 这样在不影响使用旧版本的用户的前提下，我们新的版本也发布出去了。想要使用v2版本的代码包的用户只需按修改后的引入路径下载即可。\ngo get github.com/q1mi/hello/v2@v2.0.0 在代码中使用的过程与之前类似，只是需要注意引入路径要添加 v2 版本后缀。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/q1mi/hello/v2\u0026#34; // 引入v2版本 ) func main() { fmt.Println(\u0026#34;现在是假期时间...\u0026#34;) hello.SayHi(\u0026#34;张三\u0026#34;) // v2版本的SayHi函数需要传入字符串参数 } 废弃已发布版本\n如果某个发布的版本存在致命缺陷不再想让用户使用时，我们可以使用retract声明废弃的版本。例如我们在hello/go.mod文件中按如下方式声明即可对外废弃v0.1.2版本。\nmodule github.com/q1mi/hello go 1.16 retract v0.1.2 用户使用go get下载v0.1.2版本时就会收到提示，催促其升级到其他版本。\n3.练习题 编写一个calc包实现加减乘除四个功能函数，在snow这个包中引入calc包并调用其加减乘除四个函数实现数学运算。 假设项目名称为 11\ngo mod init 11\n11/calc/xxx.go\npackage calc // Add : 加 func Add(a int, b int) int { return a + b } // Sub : 减 func Sub(a int, b int) int { return a - b } // Multi : 乘 func Multi(a int, b int) int { return a * b } // Divide : 除 func Divide(a int, b int) int { return a / b } 11/snow/main.go\npackage main import ( \u0026#34;11/calc\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { ret := calc.Add(11, 12) fmt.Println(ret) ret = calc.Sub(11, 10) fmt.Println(ret) ret = calc.Multi(11, 12) fmt.Println(ret) ret = calc.Divide(11, 12) fmt.Println(ret) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_package/","summary":"在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。 本章学习目标 掌握包的定义和使用 掌握init初始化函数的使用 掌握依赖管理工具go module的使用 在工程化的Go语言开发项目中，","title":"Golang 包"},{"content":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。\n1. 类型别名和自定义类型 1.1 自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关键字来定义自定义类型。\n自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：\n//将MyInt定义为int类型 type MyInt int 通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性。\n1.2 类型别名 类型别名是Go1.9版本添加的新功能。\n类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。\ntype TypeAlias = Type 我们之前见过的rune和byte就是类型别名，他们的定义如下：\ntype byte = uint8 type rune = int32 1.3 类型定义和类型别名的区别 类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。\n//类型定义 type NewInt int //类型别名 type MyInt = int func main() { var a NewInt var b MyInt fmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, a) //type of a:main.NewInt fmt.Printf(\u0026#34;type of b:%T\\n\u0026#34;, b) //type of b:int } 结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。\n2.结构体 Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。\nGo语言中通过struct来实现面向对象。\n2.1 结构体的定义 使用type和struct关键字来定义结构体，具体代码格式如下：\ntype 类型名 struct { 字段名 字段类型 字段名 字段类型 … } 其中：\n类型名：标识自定义结构体的名称，在同一个包内不能重复。 字段名：表示结构体字段名。结构体中的字段名必须唯一。 字段类型：表示结构体字段的具体类型。 举个例子，我们定义一个Person（人）结构体，代码如下：\ntype person struct { name string city string age int8 } 同样类型的字段也可以写在一行，\ntype person1 struct { name, city string age int8 } 这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。\n语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型\n2.2 结构体实例化 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。\n结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。\nvar 结构体实例 结构体类型 2.2.1 基本实例化 举个例子：\ntype person struct { name string city string age int8 } func main() { var p1 person p1.name = \u0026#34;沙河娜扎\u0026#34; p1.city = \u0026#34;北京\u0026#34; p1.age = 18 fmt.Printf(\u0026#34;p1=%v\\n\u0026#34;, p1) //p1={沙河娜扎 北京 18} fmt.Printf(\u0026#34;p1=%#v\\n\u0026#34;, p1) //p1=main.person{name:\u0026#34;沙河娜扎\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} } 我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。\n2.2.2 匿名结构体 在定义一些临时数据结构等场景下还可以使用匿名结构体。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { var user struct{Name string; Age int} user.Name = \u0026#34;小王子\u0026#34; user.Age = 18 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, user) } 2.2.3 创建指针类型结构体 我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：\nvar p2 = new(person) fmt.Printf(\u0026#34;%T\\n\u0026#34;, p2) //*main.person fmt.Printf(\u0026#34;p2=%#v\\n\u0026#34;, p2) //p2=\u0026amp;main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;\u0026#34;, age:0} 从打印的结果中我们可以看出p2是一个结构体指针。\n需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。\nvar p2 = new(person) p2.name = \u0026#34;小王子\u0026#34; p2.age = 28 p2.city = \u0026#34;上海\u0026#34; fmt.Printf(\u0026#34;p2=%#v\\n\u0026#34;, p2) //p2=\u0026amp;main.person{name:\u0026#34;小王子\u0026#34;, city:\u0026#34;上海\u0026#34;, age:28} 2.2.4 取结构体的地址实例化 使用\u0026amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。\np3 := \u0026amp;person{} fmt.Printf(\u0026#34;%T\\n\u0026#34;, p3) //*main.person fmt.Printf(\u0026#34;p3=%#v\\n\u0026#34;, p3) //p3=\u0026amp;main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;\u0026#34;, age:0} p3.name = \u0026#34;七米\u0026#34; p3.age = 30 p3.city = \u0026#34;成都\u0026#34; fmt.Printf(\u0026#34;p3=%#v\\n\u0026#34;, p3) //p3=\u0026amp;main.person{name:\u0026#34;七米\u0026#34;, city:\u0026#34;成都\u0026#34;, age:30} p3.name = \u0026quot;七米\u0026quot;其实在底层是(*p3).name = \u0026quot;七米\u0026quot;，这是Go语言帮我们实现的语法糖。\n2.3 结构体初始化 没有初始化的结构体，其成员变量都是对应其类型的零值。\ntype person struct { name string city string age int8 } func main() { var p4 person fmt.Printf(\u0026#34;p4=%#v\\n\u0026#34;, p4) //p4=main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;\u0026#34;, age:0} } 2.3.1 使用键值对初始化 使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。\np5 := person{ name: \u0026#34;小王子\u0026#34;, city: \u0026#34;北京\u0026#34;, age: 18, } fmt.Printf(\u0026#34;p5=%#v\\n\u0026#34;, p5) //p5=main.person{name:\u0026#34;小王子\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} 也可以对结构体指针进行键值对初始化，例如：\np6 := \u0026amp;person{ name: \u0026#34;小王子\u0026#34;, city: \u0026#34;北京\u0026#34;, age: 18, } fmt.Printf(\u0026#34;p6=%#v\\n\u0026#34;, p6) //p6=\u0026amp;main.person{name:\u0026#34;小王子\u0026#34;, city:\u0026#34;北京\u0026#34;, age:18} 当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。\np7 := \u0026amp;person{ city: \u0026#34;北京\u0026#34;, } fmt.Printf(\u0026#34;p7=%#v\\n\u0026#34;, p7) //p7=\u0026amp;main.person{name:\u0026#34;\u0026#34;, city:\u0026#34;北京\u0026#34;, age:0} 2.3.2 使用值的列表初始化 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：\np8 := \u0026amp;person{ \u0026#34;沙河娜扎\u0026#34;, \u0026#34;北京\u0026#34;, 28, } fmt.Printf(\u0026#34;p8=%#v\\n\u0026#34;, p8) //p8=\u0026amp;main.person{name:\u0026#34;沙河娜扎\u0026#34;, city:\u0026#34;北京\u0026#34;, age:28} 使用这种格式初始化时，需要注意：\n必须初始化结构体的所有字段。 初始值的填充顺序必须与字段在结构体中的声明顺序一致。 该方式不能和键值初始化方式混用。 2.4 结构体内存布局 结构体占用一块连续的内存。\ntype test struct { a int8 b int8 c int8 d int8 } n := test{ 1, 2, 3, 4, } fmt.Printf(\u0026#34;n.a %p\\n\u0026#34;, \u0026amp;n.a) fmt.Printf(\u0026#34;n.b %p\\n\u0026#34;, \u0026amp;n.b) fmt.Printf(\u0026#34;n.c %p\\n\u0026#34;, \u0026amp;n.c) fmt.Printf(\u0026#34;n.d %p\\n\u0026#34;, \u0026amp;n.d) 输出：\nn.a 0xc0000a0060 n.b 0xc0000a0061 n.c 0xc0000a0062 n.d 0xc0000a0063 【进阶知识点】关于Go语言中的内存对齐推荐阅读:Go结构体的内存对齐\n2.4.1 空结构体 空结构体是不占用空间的。\nvar v struct{} fmt.Println(unsafe.Sizeof(v)) // 0 2.5 面试题 请问下面代码的执行结果是什么？\ntype student struct { name string age int } func main() { m := make(map[string]*student) stus := []student{ {name: \u0026#34;小王子\u0026#34;, age: 18}, {name: \u0026#34;娜扎\u0026#34;, age: 23}, {name: \u0026#34;大王八\u0026#34;, age: 9000}, } for _, stu := range stus { m[stu.name] = \u0026amp;stu } for k, v := range m { fmt.Println(k, \u0026#34;=\u0026gt;\u0026#34;, v.name) } } 实际上在for循环时，\u0026amp;stu 指向的地址一直不变，但指向的值一直再变，for循环结束后，\u0026amp;stu指向的值是遍历的最后一个值，这里for循环中一直是将stu的地址赋值给 m[stu.name]，所以最后所有的 m[stu.name] 的值都为 \u0026amp;stu指向的值。\n如果想解决这个问题，只需重新声明一个局部变量 stu 变量，把 for 循环的 stu 变量给存储下来，再赋值。\nfor _, stu := range stus { stu := stu m[stu.name] = \u0026amp;stu } 2.6 构造函数 Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。\nfunc newPerson(name, city string, age int8) *person { return \u0026amp;person{ name: name, city: city, age: age, } } 调用构造函数\np9 := newPerson(\u0026#34;张三\u0026#34;, \u0026#34;沙河\u0026#34;, 90) fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p9) //\u0026amp;main.person{name:\u0026#34;张三\u0026#34;, city:\u0026#34;沙河\u0026#34;, age:90} 2.7 方法和接收者 Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。\n方法的定义格式如下：\nfunc (接收者变量 接收者类型) 方法名(参数列表) (返回参数) { 函数体 } 其中，\n接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。 方法名、参数列表、返回参数：具体格式与函数定义相同。 举个例子：\n//Person 结构体 type Person struct { name string age int8 } //NewPerson 构造函数 func NewPerson(name string, age int8) *Person { return \u0026amp;Person{ name: name, age: age, } } //Dream Person做梦的方法 func (p Person) Dream() { fmt.Printf(\u0026#34;%s的梦想是学好Go语言！\\n\u0026#34;, p.name) } func main() { p1 := NewPerson(\u0026#34;小王子\u0026#34;, 25) p1.Dream() } 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。\n2.7.1 指针类型的接收者 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。\n// SetAge 设置p的年龄 // 使用指针接收者 func (p *Person) SetAge(newAge int8) { p.age = newAge } 调用该方法：\nfunc main() { p1 := NewPerson(\u0026#34;小王子\u0026#34;, 25) fmt.Println(p1.age) // 25 p1.SetAge(30) fmt.Println(p1.age) // 30 } 2.7.2 值类型的接收者 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。\n// SetAge2 设置p的年龄 // 使用值接收者 func (p Person) SetAge2(newAge int8) { p.age = newAge } func main() { p1 := NewPerson(\u0026#34;小王子\u0026#34;, 25) p1.Dream() fmt.Println(p1.age) // 25 p1.SetAge2(30) // (*p1).SetAge2(30) fmt.Println(p1.age) // 25 } 2.7.3 什么时候应该使用指针类型接收者 需要修改接收者中的值 接收者是拷贝代价比较大的大对象 保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。 2.8 任意类型添加方法 在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。\n//MyInt 将int定义为自定义MyInt类型 type MyInt int //SayHello 为MyInt添加一个SayHello的方法 func (m MyInt) SayHello() { fmt.Println(\u0026#34;Hello, 我是一个int。\u0026#34;) } func main() { var m1 MyInt m1.SayHello() //Hello, 我是一个int。 m1 = 100 fmt.Printf(\u0026#34;%#v %T\\n\u0026#34;, m1, m1) //100 main.MyInt } 注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。\n2.9 结构体的匿名字段 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。\n//Person 结构体Person类型 type Person struct { string int } func main() { p1 := Person{ \u0026#34;小王子\u0026#34;, 18, } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, p1) //main.Person{string:\u0026#34;北京\u0026#34;, int:18} fmt.Println(p1.string, p1.int) //北京 18 } **注意：**这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。\n2.10 嵌套结构体 一个结构体中可以嵌套包含另一个结构体或结构体指针，就像下面的示例代码那样。\n//Address 地址结构体 type Address struct { Province string City string } //User 用户结构体 type User struct { Name string Gender string Address Address } func main() { user1 := User{ Name: \u0026#34;小王子\u0026#34;, Gender: \u0026#34;男\u0026#34;, Address: Address{ Province: \u0026#34;山东\u0026#34;, City: \u0026#34;威海\u0026#34;, }, } fmt.Printf(\u0026#34;user1=%#v\\n\u0026#34;, user1)//user1=main.User{Name:\u0026#34;小王子\u0026#34;, Gender:\u0026#34;男\u0026#34;, Address:main.Address{Province:\u0026#34;山东\u0026#34;, City:\u0026#34;威海\u0026#34;}} } 2.10.1 嵌套匿名字段 上面user结构体中嵌套的Address结构体也可以采用匿名字段的方式，例如：\n//Address 地址结构体 type Address struct { Province string City string } //User 用户结构体 type User struct { Name string Gender string Address //匿名字段 } func main() { var user2 User user2.Name = \u0026#34;小王子\u0026#34; user2.Gender = \u0026#34;男\u0026#34; user2.Address.Province = \u0026#34;山东\u0026#34; // 匿名字段默认使用类型名作为字段名 user2.City = \u0026#34;威海\u0026#34; // 匿名字段可以省略 fmt.Printf(\u0026#34;user2=%#v\\n\u0026#34;, user2) //user2=main.User{Name:\u0026#34;小王子\u0026#34;, Gender:\u0026#34;男\u0026#34;, Address:main.Address{Province:\u0026#34;山东\u0026#34;, City:\u0026#34;威海\u0026#34;}} } 当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。\n2.10.2 嵌套结构体的字段名冲突 嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。\n//Address 地址结构体 type Address struct { Province string City string CreateTime string } //Email 邮箱结构体 type Email struct { Account string CreateTime string } //User 用户结构体 type User struct { Name string Gender string Address Email } func main() { var user3 User user3.Name = \u0026#34;沙河娜扎\u0026#34; user3.Gender = \u0026#34;男\u0026#34; // user3.CreateTime = \u0026#34;2019\u0026#34; //ambiguous selector user3.CreateTime user3.Address.CreateTime = \u0026#34;2000\u0026#34; //指定Address结构体中的CreateTime user3.Email.CreateTime = \u0026#34;2000\u0026#34; //指定Email结构体中的CreateTime } 2.11 结构体的“继承” Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。\n//Animal 动物 type Animal struct { name string } func (a *Animal) move() { fmt.Printf(\u0026#34;%s会动！\\n\u0026#34;, a.name) } //Dog 狗 type Dog struct { Feet int8 *Animal //通过嵌套匿名结构体实现继承 } func (d *Dog) wang() { fmt.Printf(\u0026#34;%s会汪汪汪~\\n\u0026#34;, d.name) } func main() { d1 := \u0026amp;Dog{ Feet: 4, Animal: \u0026amp;Animal{ //注意嵌套的是结构体指针 name: \u0026#34;乐乐\u0026#34;, }, } d1.wang() //乐乐会汪汪汪~ d1.move() //乐乐会动！ } 2.12 结构体字段的可见性 结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。\n2.13 结构体与JSON序列化 JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号\u0026quot;\u0026quot;包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。\n//Student 学生 type Student struct { ID int Gender string Name string } //Class 班级 type Class struct { Title string Students []*Student } func main() { c := \u0026amp;Class{ Title: \u0026#34;101\u0026#34;, Students: make([]*Student, 0, 200), } for i := 0; i \u0026lt; 10; i++ { stu := \u0026amp;Student{ Name: fmt.Sprintf(\u0026#34;stu%02d\u0026#34;, i), Gender: \u0026#34;男\u0026#34;, ID: i, } c.Students = append(c.Students, stu) } //JSON序列化：结构体--\u0026gt;JSON格式的字符串 data, err := json.Marshal(c) if err != nil { fmt.Println(\u0026#34;json marshal failed\u0026#34;) return } fmt.Printf(\u0026#34;json:%s\\n\u0026#34;, data) //JSON反序列化：JSON格式的字符串--\u0026gt;结构体 str := `{\u0026#34;Title\u0026#34;:\u0026#34;101\u0026#34;,\u0026#34;Students\u0026#34;:[{\u0026#34;ID\u0026#34;:0,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu00\u0026#34;},{\u0026#34;ID\u0026#34;:1,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu01\u0026#34;},{\u0026#34;ID\u0026#34;:2,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu02\u0026#34;},{\u0026#34;ID\u0026#34;:3,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu03\u0026#34;},{\u0026#34;ID\u0026#34;:4,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu04\u0026#34;},{\u0026#34;ID\u0026#34;:5,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu05\u0026#34;},{\u0026#34;ID\u0026#34;:6,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu06\u0026#34;},{\u0026#34;ID\u0026#34;:7,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu07\u0026#34;},{\u0026#34;ID\u0026#34;:8,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu08\u0026#34;},{\u0026#34;ID\u0026#34;:9,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;stu09\u0026#34;}]}` c1 := \u0026amp;Class{} err = json.Unmarshal([]byte(str), c1) if err != nil { fmt.Println(\u0026#34;json unmarshal failed!\u0026#34;) return } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, c1) } 2.14 结构体标签（Tag） Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：\n`key1:\u0026#34;value1\u0026#34; key2:\u0026#34;value2\u0026#34;` 结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。\n注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。\n例如我们为Student结构体的每个字段定义json序列化时使用的Tag：\n//Student 学生 type Student struct { ID int `json:\u0026#34;id\u0026#34;` //通过指定tag实现json序列化该字段时的key Gender string //json序列化是默认使用字段名作为key name string //私有不能被json包访问 } func main() { s1 := Student{ ID: 1, Gender: \u0026#34;男\u0026#34;, name: \u0026#34;沙河娜扎\u0026#34;, } data, err := json.Marshal(s1) if err != nil { fmt.Println(\u0026#34;json marshal failed!\u0026#34;) return } fmt.Printf(\u0026#34;json str:%s\\n\u0026#34;, data) //json str:{\u0026#34;id\u0026#34;:1,\u0026#34;Gender\u0026#34;:\u0026#34;男\u0026#34;} } 2.15 结构体和方法补充知识点 因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：\ntype Person struct { name string age int8 dreams []string } func (p *Person) SetDreams(dreams []string) { p.dreams = dreams } func main() { p1 := Person{name: \u0026#34;小王子\u0026#34;, age: 18} data := []string{\u0026#34;吃饭\u0026#34;, \u0026#34;睡觉\u0026#34;, \u0026#34;打豆豆\u0026#34;} p1.SetDreams(data) // 你真的想要修改 p1.dreams 吗？ data[1] = \u0026#34;不睡觉\u0026#34; fmt.Println(p1.dreams) // ? } 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。\nfunc (p *Person) SetDreams(dreams []string) { p.dreams = make([]string, len(dreams)) copy(p.dreams, dreams) } 同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。\n3. 练习题 使用“面向对象”的思维方式编写一个学生信息管理系统。 学生有id、姓名、年龄、分数等信息 程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能 main.go\nfunc showMenu() { fmt.Println(\u0026#34;欢迎来到学生管理系统\u0026#34;) fmt.Println(\u0026#34;1. 添加学生\u0026#34;) fmt.Println(\u0026#34;2. 编辑学生信息\u0026#34;) fmt.Println(\u0026#34;3. 展示所有学生信息\u0026#34;) fmt.Println(\u0026#34;4. 删除学生信息\u0026#34;) fmt.Println(\u0026#34;5. 退出系统\u0026#34;) } // 获取用户输入的学生信息 func getInput() *student { var ( id int name string age int grade int ) fmt.Println(\u0026#34;请按要求输入学生的信息\u0026#34;) fmt.Print(\u0026#34;请输入学生的学号：\u0026#34;) fmt.Scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;id) fmt.Print(\u0026#34;请输入学生的姓名：\u0026#34;) fmt.Scanf(\u0026#34;%s\\n\u0026#34;, \u0026amp;name) fmt.Print(\u0026#34;请输入学生的年龄：\u0026#34;) fmt.Scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;age) fmt.Print(\u0026#34;请输入学生的分数：\u0026#34;) fmt.Scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;grade) //构造一个学生对象 stu := newStudent(id, name, age, grade) return stu } func main() { stuMS := newStuMS() for { //1.打印系统菜单 showMenu() //2.等待用户输入选项 var input int fmt.Println(\u0026#34;请输入你要操作的序号：\u0026#34;) fmt.Scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;input) //3.执行用户输入的操作 switch input { case 1: // 添加学生 stu := getInput() stuMS.addStudent(stu) case 2: // 编辑学生信息 stu := getInput() stuMS.editStudent(stu) case 3: // 展示所有学生信息 stuMS.showStudent() case 4: // 删除学生信息 stu := getInput() stuMS.delStudent(stu) case 5: os.Exit(0) } } } student.go\n//使用“面向对象”的思维方式编写一个学生信息管理系统。 //学生有id、姓名、年龄、分数等信息 //程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能 // 学生类，有id、姓名、年龄、分数 type student struct { id int name string age int grade int } // 学生管理系统 type StuMS struct { StuList []*student } // Student 类 的构造函数 func newStudent(id int, name string, age int, grade int) *student { return \u0026amp;student{ id: id, name: name, age: age, grade: grade, } } // 学生管理系统的构造函数 func newStuMS() *StuMS { return \u0026amp;StuMS{ StuList: make([]*student, 0, 100), } } // 添加学生 func (s *StuMS) addStudent(newStu *student) { s.StuList = append(s.StuList, newStu) } // 编辑学生信息 func (s *StuMS) editStudent(newStu *student) { for i, v := range s.StuList { if v.id == newStu.id { s.StuList[i] = newStu return } } fmt.Printf(\u0026#34;输入信息有误，系统中没有学号为 %d 的学生\\n\u0026#34;, newStu.id) } // 展示学生列表 func (s *StuMS) showStudent() { for _, v := range s.StuList { fmt.Printf(\u0026#34;学号：%d 姓名：%s 年龄：%d 分数:%d\\n\u0026#34;, v.id, v.name, v.age, v.grade) } } // 删除学生 // a = append(a[:index], a[index+1:]...) func (s *StuMS) delStudent(newStu *student) { for i, v := range s.StuList { if v.id == newStu.id { s.StuList = append(s.StuList[:i], s.StuList[i+1:]...) return } } fmt.Printf(\u0026#34;输入信息有误，系统中没有学号为 %d 的学生\\n\u0026#34;, newStu.id) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_struct/","summary":"Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 1. 类型别名和自定义类型 1.1 自定义类型 在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型， Go语言中可以使用type关","title":"Golang 结构体"},{"content":"Golang指针 区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。\n要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。\n1 Go语言中的指针 任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\n比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量A，把内存地址赋值给变量B。这时候变量B就是一个指针变量。通过变量A和变量B都能找到我的座右铭。\nGo语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：\u0026amp;（取地址）和*（根据地址取值）。\n1.1 指针地址和指针类型 每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用\u0026amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：*int、*int64、*string等。\n取变量指针的语法如下：\nptr := \u0026amp;v // v的类型为T 其中：\nv:代表被取地址的变量，类型为T ptr:用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。 举个例子：\nfunc main() { a := 10 b := \u0026amp;a fmt.Printf(\u0026#34;a:%d ptr:%p\\n\u0026#34;, a, \u0026amp;a) // a:10 ptr:0xc00001a078 fmt.Printf(\u0026#34;b:%p type:%T\\n\u0026#34;, b, b) // b:0xc00001a078 type:*int fmt.Println(\u0026amp;b) // 0xc00000e018 } 我们来看一下b := \u0026amp;a的图示：\n1.2 指针取值 在对普通变量使用\u0026amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。\nfunc main() { //指针取值 a := 10 b := \u0026amp;a // 取变量a的地址，将指针保存到b中 fmt.Printf(\u0026#34;type of b:%T\\n\u0026#34;, b) c := *b // 指针取值（根据指针去内存取值） fmt.Printf(\u0026#34;type of c:%T\\n\u0026#34;, c) fmt.Printf(\u0026#34;value of c:%v\\n\u0026#34;, c) } 输出如下：\ntype of b:*int type of c:int value of c:10 总结： 取地址操作符\u0026amp;和取值操作符*是一对互补操作符，\u0026amp;取出地址，*根据地址取出地址指向的值。\n变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：\n对变量进行取地址（\u0026amp;）操作，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。 指针传值示例：\nfunc modify1(x int) { x = 100 } func modify2(x *int) { *x = 100 } func main() { a := 10 modify1(a) fmt.Println(a) // 10 modify2(\u0026amp;a) fmt.Println(a) // 100 } 1.3 new和make 我们先来看一个例子：\nfunc main() { var a *int *a = 100 fmt.Println(*a) var b map[string]int b[\u0026#34;沙河娜扎\u0026#34;] = 100 fmt.Println(b) } 执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。\n1.3.1 new new是一个内置的函数，它的函数签名如下：\nfunc new(Type) *Type 其中，\nType表示类型，new函数只接受一个参数，这个参数是一个类型 *Type表示类型指针，new函数返回一个指向该类型内存地址的指针。 new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：\nfunc main() { a := new(int) b := new(bool) fmt.Printf(\u0026#34;%T\\n\u0026#34;, a) // *int fmt.Printf(\u0026#34;%T\\n\u0026#34;, b) // *bool fmt.Println(*a) // 0 fmt.Println(*b) // false }\t本节开始的示例代码中var a *int只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：\nfunc main() { var a *int a = new(int) *a = 10 fmt.Println(*a) } 1.3.2 make make也是用于内存分配的，区别于new，它只用于slice、map以及channel的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：\nfunc make(t Type, size ...IntegerType) Type make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。\n本节开始的示例中var b map[string]int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：\nfunc main() { var b map[string]int b = make(map[string]int, 10) b[\u0026#34;沙河娜扎\u0026#34;] = 100 fmt.Println(b) } 1.3.3 new与make的区别 二者都是用来做内存分配的。 make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身； 而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。 ","permalink":"https://N3bu74.github.io/posts/tech/golang_pointer/","summary":"Golang指针 区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。 要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。 1 Go语言中的指针 任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就","title":"Golang 指针"},{"content":"函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。\n1.函数 Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。\n1.1 函数定义 Go语言中定义函数使用func关键字，具体格式如下：\nfunc 函数名(参数)(返回值){ 函数体 } 其中：\n函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。 参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔。 函数体：实现指定功能的代码块。 我们先来定义一个求两个数之和的函数：\nfunc intSum(x int, y int) int { return x + y } 函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：\nfunc sayHello() { fmt.Println(\u0026#34;Hello 沙河\u0026#34;) } 1.2 函数的调用 定义了函数之后，我们可以通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：\nfunc main() { sayHello() ret := intSum(10, 20) fmt.Println(ret) } 注意，调用有返回值的函数时，可以不接收其返回值。\n1.3 参数 1.3.1 类型简写 函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：\nfunc intSum(x, y int) int { return x + y } 上面的代码中，intSum函数有两个参数，这两个参数的类型均为int，因此可以省略x的类型，因为y后面有类型说明，x参数也是该类型。\n1.3.2 可变参数 可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加...来标识。\n注意：可变参数通常要作为函数的最后一个参数。\n举个例子：\nfunc intSum2(x ...int) int { fmt.Println(x) //x是一个切片 sum := 0 for _, v := range x { sum = sum + v } return sum } 调用上面的函数：\nret1 := intSum2() ret2 := intSum2(10) ret3 := intSum2(10, 20) ret4 := intSum2(10, 20, 30) fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60 固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：\nfunc intSum3(x int, y ...int) int { fmt.Println(x, y) sum := x for _, v := range y { sum = sum + v } return sum } 调用上述函数：\nret5 := intSum3(100) ret6 := intSum3(100, 10) ret7 := intSum3(100, 10, 20) ret8 := intSum3(100, 10, 20, 30) fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160 本质上，函数的可变参数是通过切片来实现的。\n1.4 返回值 Go语言中通过return关键字向外输出返回值。\n1.4.1多返回值 Go语言中函数支持多返回值，函数如果有多个返回值时必须用()将所有返回值包裹起来。\n举个例子：\nfunc calc(x, y int) (int, int) { sum := x + y sub := x - y return sum, sub } 1.4.2 返回值命名 函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回。\n例如：\nfunc calc(x, y int) (sum, sub int) { sum = x + y sub = x - y return } 1.4.3 返回值补充 当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。\nfunc someFunc(x string) []int { if x == \u0026#34;\u0026#34; { return nil // 没必要返回[]int{} } ... } 2.函数进阶 2.1 变量作用域 2.1.1 全局变量 全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。\npackage main import \u0026#34;fmt\u0026#34; //定义全局变量num var num int64 = 10 func testGlobalVar() { fmt.Printf(\u0026#34;num=%d\\n\u0026#34;, num) //函数中可以访问全局变量num } func main() { testGlobalVar() //num=10 } 2.1.2 局部变量 局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：\nfunc testLocalVar() { //定义一个函数局部变量x,仅在该函数内生效 var x int64 = 100 fmt.Printf(\u0026#34;x=%d\\n\u0026#34;, x) } func main() { testLocalVar() fmt.Println(x) // 此时无法使用变量x } 如果局部变量和全局变量重名，优先访问局部变量。\npackage main import \u0026#34;fmt\u0026#34; //定义全局变量num var num int64 = 10 func testNum() { num := 100 fmt.Printf(\u0026#34;num=%d\\n\u0026#34;, num) // 函数中优先使用局部变量 } func main() { testNum() // num=100 } 接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。\nfunc testLocalVar2(x, y int) { fmt.Println(x, y) //函数的参数也是只在本函数中生效 if x \u0026gt; 0 { z := 100 //变量z只在if语句块生效 fmt.Println(z) } //fmt.Println(z)//此处无法使用变量z } 还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：\nfunc testLocalVar3() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) //变量i只在当前for语句块中生效 } //fmt.Println(i) //此处无法使用变量i } 2.2 函数类型与变量 2.2.1 定义函数类型 我们可以使用type关键字来定义一个函数类型，具体格式如下：\ntype calculation func(int, int) int 上面语句定义了一个calculation类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。\n简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。\nfunc add(x, y int) int { return x + y } func sub(x, y int) int { return x - y } add和sub都能赋值给calculation类型的变量。\nvar c calculation c = add 2.2.2 函数类型变量 我们可以声明函数类型的变量并且为该变量赋值：\nfunc main() { var c calculation // 声明一个calculation类型的变量c c = add // 把add赋值给c fmt.Printf(\u0026#34;type of c:%T\\n\u0026#34;, c) // type of c:main.calculation fmt.Println(c(1, 2)) // 像调用add一样调用c f := add // 将函数add赋值给变量f fmt.Printf(\u0026#34;type of f:%T\\n\u0026#34;, f) // type of f:func(int, int) int fmt.Println(f(10, 20)) // 像调用add一样调用f } 2.3 高阶函数 高阶函数分为函数作为参数和函数作为返回值两部分。\n2.3.1 函数作为参数 函数可以作为参数：\nfunc add(x, y int) int { return x + y } func calc(x, y int, op func(int, int) int) int { return op(x, y) } func main() { ret2 := calc(10, 20, add) fmt.Println(ret2) //30 } 2.3.2 函数作为返回值 函数也可以作为返回值：\nfunc do(s string) (func(int, int) int, error) { switch s { case \u0026#34;+\u0026#34;: return add, nil case \u0026#34;-\u0026#34;: return sub, nil default: err := errors.New(\u0026#34;无法识别的操作符\u0026#34;) return nil, err } } 2.4 匿名函数和闭包 2.4.1 匿名函数 函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：\nfunc(参数)(返回值){ 函数体 } 匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:\nfunc main() { // 将匿名函数保存到变量 add := func(x, y int) { fmt.Println(x + y) } add(10, 20) // 通过变量调用匿名函数 //自执行函数：匿名函数定义完加()直接执行 func(x, y int) { fmt.Println(x + y) }(10, 20) } 匿名函数多用于实现回调函数和闭包。\n2.4.2 闭包 闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境(外层变量的引用)。 首先我们来看一个例子：\nfunc adder() func(int) int { var x int return func(y int) int { x += y return x } } func main() { var f = adder() fmt.Println(f(10)) //10 fmt.Println(f(20)) //30 fmt.Println(f(30)) //60 f1 := adder() fmt.Println(f1(40)) //40 fmt.Println(f1(50)) //90 } 变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。 闭包进阶示例1：\nfunc adder2(x int) func(int) int { return func(y int) int { x += y return x } } func main() { var f = adder2(10) fmt.Println(f(10)) //20 fmt.Println(f(20)) //40 fmt.Println(f(30)) //70 f1 := adder2(20) fmt.Println(f1(40)) //60 fmt.Println(f1(50)) //110 } 闭包进阶示例2：\nfunc makeSuffixFunc(suffix string) func(string) string { return func(name string) string { if !strings.HasSuffix(name, suffix) { return name + suffix } return name } } func main() { jpgFunc := makeSuffixFunc(\u0026#34;.jpg\u0026#34;) txtFunc := makeSuffixFunc(\u0026#34;.txt\u0026#34;) fmt.Println(jpgFunc(\u0026#34;test\u0026#34;)) //test.jpg fmt.Println(txtFunc(\u0026#34;test\u0026#34;)) //test.txt } 闭包进阶示例3：\nfunc calc(base int) (func(int) int, func(int) int) { add := func(i int) int { base += i return base } sub := func(i int) int { base -= i return base } return add, sub } func main() { f1, f2 := calc(10) fmt.Println(f1(1), f2(2)) //11 9 fmt.Println(f1(3), f2(4)) //12 8 fmt.Println(f1(5), f2(6)) //13 7 } 闭包其实并不复杂，只要牢记闭包=函数+引用环境。\n2.5 defer语句 Go语言中的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。\n举个例子：\nfunc main() { fmt.Println(\u0026#34;start\u0026#34;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(\u0026#34;end\u0026#34;) } 输出结果：\nstart end 3 2 1 由于defer语句延迟调用的特性，所以defer语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。\n2.5.1 defer执行时机 在Go语言的函数中return语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而defer语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：\n2.5.2 defer经典案例 阅读下面的代码，写出最后的打印结果。\nfunc f1() int { x := 5 defer func() { x++ }() return x } func f2() (x int) { defer func() { x++ }() return 5 } func f3() (y int) { x := 5 defer func() { x++ }() return x } func f4() (x int) { defer func(x int) { x++ }(x) return 5 } func main() { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) fmt.Println(f4()) } 2.5.3 defer面试题 func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret } func main() { x := 1 y := 2 defer calc(\u0026#34;AA\u0026#34;, x, calc(\u0026#34;A\u0026#34;, x, y)) x = 10 defer calc(\u0026#34;BB\u0026#34;, x, calc(\u0026#34;B\u0026#34;, x, y)) y = 20 } 问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）\nA 1 2 3 B 10 2 12 BB 10 12 22 AA 1 3 4 3.内置函数介绍 内置函数 介绍 close 主要用来关闭channel len 用来求长度，比如string、array、slice、map、channel new 用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针 make 用来分配内存，主要用来分配引用类型，比如chan、map、slice append 用来追加元素到数组、slice中 panic和recover 用来做错误处理 3.1 panic/recover Go语言中目前（Go1.12）是没有异常机制，但是使用panic/recover模式来处理错误。 panic可以在任何地方引发，但recover只有在defer调用的函数中有效。 首先来看一个例子：\nfunc funcA() { fmt.Println(\u0026#34;func A\u0026#34;) } func funcB() { panic(\u0026#34;panic in B\u0026#34;) } func funcC() { fmt.Println(\u0026#34;func C\u0026#34;) } func main() { funcA() funcB() funcC() } 输出：\nfunc A panic: panic in B goroutine 1 [running]: main.funcB(...) .../code/func/main.go:12 main.main() .../code/func/main.go:20 +0x98 程序运行期间funcB中引发了panic导致程序崩溃，异常退出了。这个时候我们就可以通过recover将程序恢复回来，继续往后执行。\nfunc funcA() { fmt.Println(\u0026#34;func A\u0026#34;) } func funcB() { defer func() { err := recover() //如果程序出出现了panic错误,可以通过recover恢复过来 if err != nil { fmt.Println(\u0026#34;recover in B\u0026#34;) } }() panic(\u0026#34;panic in B\u0026#34;) } func funcC() { fmt.Println(\u0026#34;func C\u0026#34;) } func main() { funcA() funcB() funcC() } 注意：\nrecover()必须搭配defer使用。 defer一定要在可能引发panic的语句之前定义。 4.练习题 分金币 /* 你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。 分配规则如下： a. 名字中每包含1个\u0026#39;e\u0026#39;或\u0026#39;E\u0026#39;分1枚金币 b. 名字中每包含1个\u0026#39;i\u0026#39;或\u0026#39;I\u0026#39;分2枚金币 c. 名字中每包含1个\u0026#39;o\u0026#39;或\u0026#39;O\u0026#39;分3枚金币 d: 名字中每包含1个\u0026#39;u\u0026#39;或\u0026#39;U\u0026#39;分4枚金币 写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？ 程序结构如下，请实现 ‘dispatchCoin’ 函数 */ var ( coins = 50 users = []string{ \u0026#34;Matthew\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Augustus\u0026#34;, \u0026#34;Heidi\u0026#34;, \u0026#34;Emilie\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Giana\u0026#34;, \u0026#34;Adriano\u0026#34;, \u0026#34;Aaron\u0026#34;, \u0026#34;Elizabeth\u0026#34;, } distribution = make(map[string]int, len(users)) ) func main() { left := dispatchCoin() fmt.Println(\u0026#34;剩下：\u0026#34;, left) } package main import \u0026#34;fmt\u0026#34; func dispatchCoin() int { var ( coins = 50 users = []string{ \u0026#34;Matthew\u0026#34;, \u0026#34;Sarah\u0026#34;, \u0026#34;Augustus\u0026#34;, \u0026#34;Heidi\u0026#34;, \u0026#34;Emilie\u0026#34;, \u0026#34;Peter\u0026#34;, \u0026#34;Giana\u0026#34;, \u0026#34;Adriano\u0026#34;, \u0026#34;Aaron\u0026#34;, \u0026#34;Elizabeth\u0026#34;, } distribution = make(map[string]int, len(users)) ) for _, user := range users { getCoin := 0 for _, u := range user { switch u { case \u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;: getCoin += 1 case \u0026#39;i\u0026#39;, \u0026#39;I\u0026#39;: getCoin += 2 case \u0026#39;o\u0026#39;, \u0026#39;O\u0026#39;: getCoin += 3 case \u0026#39;u\u0026#39;, \u0026#39;U\u0026#39;: getCoin += 4 } } distribution[user] = getCoin coins -= getCoin } fmt.Println(distribution) return coins } func main() { left := dispatchCoin() fmt.Println(\u0026#34;剩下：\u0026#34;, left) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_function/","summary":"函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。 1.函数 Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。 1.1 函数定义 Go语言中定义函数使用func关键字，具体格式如下： func 函数名(参数)(返回值){ 函数体 } 其中： 函","title":"Golang函数"},{"content":"Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。\n1.map map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。\n1.1 map定义 Go语言中 map的定义语法如下：\nmap[KeyType]ValueType 其中，\nKeyType:表示键的类型。 ValueType:表示键对应的值的类型。 map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：\nmake(map[KeyType]ValueType, [cap]) 其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。\n1.2 map基本使用 map中的数据都是成对出现的，map的基本使用示例代码如下：\nfunc main() { scoreMap := make(map[string]int, 8) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 fmt.Println(scoreMap) fmt.Println(scoreMap[\u0026#34;小明\u0026#34;]) fmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, scoreMap) } 输出：\nmap[小明:100 张三:90] 100 type of a:map[string]int map也支持在声明的时候填充元素，例如：\nfunc main() { userInfo := map[string]string{ \u0026#34;username\u0026#34;: \u0026#34;沙河小王子\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;123456\u0026#34;, } fmt.Println(userInfo) // } 1.3 判断某个键是否存在 Go语言中有个判断map中键是否存在的特殊写法，格式如下:\nvalue, ok := map[key] 举个例子：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 // 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值 v, ok := scoreMap[\u0026#34;张三\u0026#34;] if ok { fmt.Println(v) } else { fmt.Println(\u0026#34;查无此人\u0026#34;) } } 1.4 map的遍历 Go语言中使用for range遍历map。\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 for k, v := range scoreMap { fmt.Println(k, v) } } 但我们只想遍历key的时候，可以按下面的写法：\nfunc main() { scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 for k := range scoreMap { fmt.Println(k) } } 注意： 遍历map时的元素顺序与添加键值对的顺序无关。\n1.5 使用delete()函数删除键值对 使用delete()内建函数从map中删除一组键值对，delete()函数的格式如下：\ndelete(map, key) 其中，\nmap:表示要删除键值对的map key:表示要删除的键值对的键 示例代码如下：\nfunc main(){ scoreMap := make(map[string]int) scoreMap[\u0026#34;张三\u0026#34;] = 90 scoreMap[\u0026#34;小明\u0026#34;] = 100 scoreMap[\u0026#34;娜扎\u0026#34;] = 60 delete(scoreMap, \u0026#34;小明\u0026#34;)//将小明:100从map中删除 for k,v := range scoreMap{ fmt.Println(k, v) } } 1.6 按照指定顺序遍历map func main() { rand.Seed(time.Now().UnixNano()) //初始化随机数种子 var scoreMap = make(map[string]int, 200) for i := 0; i \u0026lt; 100; i++ { key := fmt.Sprintf(\u0026#34;stu%02d\u0026#34;, i) //生成stu开头的字符串 value := rand.Intn(100) //生成0~99的随机整数 scoreMap[key] = value } //取出map中的所有key存入切片keys var keys = make([]string, 0, 200) for key := range scoreMap { keys = append(keys, key) } //对切片进行排序 sort.Strings(keys) //按照排序后的key遍历map for _, key := range keys { fmt.Println(key, scoreMap[key]) } } 1.7 元素为map类型的切片 下面的代码演示了切片中的元素为map类型时的操作：\nfunc main() { var mapSlice = make([]map[string]string, 3) for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%v\\n\u0026#34;, index, value) } fmt.Println(\u0026#34;after init\u0026#34;) // 对切片中的map元素进行初始化 mapSlice[0] = make(map[string]string, 10) mapSlice[0][\u0026#34;name\u0026#34;] = \u0026#34;小王子\u0026#34; mapSlice[0][\u0026#34;password\u0026#34;] = \u0026#34;123456\u0026#34; mapSlice[0][\u0026#34;address\u0026#34;] = \u0026#34;沙河\u0026#34; for index, value := range mapSlice { fmt.Printf(\u0026#34;index:%d value:%v\\n\u0026#34;, index, value) } } 1.8 值为切片类型的map 下面的代码演示了map中值为切片类型的操作：\nfunc main() { var sliceMap = make(map[string][]string, 3) fmt.Println(sliceMap) fmt.Println(\u0026#34;after init\u0026#34;) key := \u0026#34;中国\u0026#34; value, ok := sliceMap[key] if !ok { value = make([]string, 0, 2) } value = append(value, \u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;) sliceMap[key] = value fmt.Println(sliceMap) } 2.练习题 1.写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { str := \u0026#34;how do you do\u0026#34; splits := strings.Split(str, \u0026#34; \u0026#34;) result := make(map[string]int, 9) for _, key := range splits { result[key] += 1 } fmt.Println(result) } 2.观察下面代码，写出最终的打印结果。\nfunc main() { type Map map[string][]int m := make(Map) s := []int{1, 2} s = append(s, 3) fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s) m[\u0026#34;q1mi\u0026#34;] = s s = append(s[:1], s[2:]...) fmt.Printf(\u0026#34;%+v\\n\u0026#34;, s) fmt.Printf(\u0026#34;%+v\\n\u0026#34;, m[\u0026#34;q1mi\u0026#34;]) } 输出：\n[1 2 3] [1 3] [1 3 3] 原因：\n自始至终只有一个堆区的底层数组 切片的操作不过是改变了size而已\n切片：包含指针，长度和容量 m[\u0026ldquo;q1mi\u0026rdquo;] 和 s 指向同一个数组：[1 2 3] s 切片删除了下标为 1 的元素，直接在共享数组修改，修改后数组为 [1 3 3] 此时 s 的指针，指向底层共享数组，长度为 2，容量为 4（容量为 4，是因为扩容一次） m[\u0026ldquo;q1mi\u0026rdquo;] 的指针，也指向底层共享数组，长度为 3，容量为 4 ","permalink":"https://N3bu74.github.io/posts/tech/golang_map/","summary":"Go语言中提供的映射关系容器为map，其内部使用散列表（hash）实现。 1.map map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。 1.1 map定义 Go语言中 map的定义语法如下： map[KeyType]ValueType 其中， KeyType:表示键的类型。 ValueType:表","title":"Golang map"},{"content":"本文主要介绍Go语言中切片（slice）及它的基本使用。\n1.引子 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：\nfunc arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum + v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如，\na := [3]int{1, 2, 3} 数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。\n2.切片 切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。\n切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。\n2.1 切片的定义 声明切片类型的基本语法如下：\nvar name []T 其中，\nname:表示变量名 T:表示切片中的元素类型 举个例子：\nfunc main() { // 声明切片类型 var a []string //声明一个字符串切片 var b = []int{} //声明一个整型切片并初始化 var c = []bool{false, true} //声明一个布尔切片并初始化 var d = []bool{false, true} //声明一个布尔切片并初始化 fmt.Println(a) //[] fmt.Println(b) //[] fmt.Println(c) //[false true] fmt.Println(a == nil) //true fmt.Println(b == nil) //false fmt.Println(c == nil) //false // fmt.Println(c == d) //切片是引用类型，不支持直接比较，只能和nil比较 } 2.1.1 切片的长度和容量 切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。\n2.1.2 切片表达式 切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。\n2.1.2.1 简单切片表达式 切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的low和high表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出1\u0026lt;=索引值\u0026lt;4的元素组成切片s，得到的切片长度=high-low，容量等于得到的切片的底层数组的容量。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\u0026#34;s:%v len(s):%v cap(s):%v\\n\u0026#34;, s, len(s), cap(s)) } 输出：\ns:[2 3] len(s):2 cap(s):4 为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:\na[2:] // 等同于 a[2:len(a)] a[:3] // 等同于 a[0:3] a[:] // 等同于 a[0:len(a)] 注意：\n对于数组或字符串，如果0 \u0026lt;= low \u0026lt;= high \u0026lt;= len(a)，则索引合法，否则就会索引越界（out of range）。\n对切片再执行切片表达式时（切片再切片），high的上限边界是切片的容量cap(a)，而不是长度。常量索引必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果low和high两个指标都是常数，它们必须满足low \u0026lt;= high。如果索引在运行时超出范围，就会发生运行时panic。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // s := a[low:high] fmt.Printf(\u0026#34;s:%v len(s):%v cap(s):%v\\n\u0026#34;, s, len(s), cap(s)) s2 := s[3:4] // 索引的上限是cap(s)而不是len(s) fmt.Printf(\u0026#34;s2:%v len(s2):%v cap(s2):%v\\n\u0026#34;, s2, len(s2), cap(s2)) } 输出：\ns:[2 3] len(s):2 cap(s):4 s2:[5] len(s2):1 cap(s2):1 2.1.2.2 完整切片表达式 对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：\na[low : high : max] 上面的代码会构造与简单切片表达式a[low: high]相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为max-low。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。\nfunc main() { a := [5]int{1, 2, 3, 4, 5} t := a[1:3:5] fmt.Printf(\u0026#34;t:%v len(t):%v cap(t):%v\\n\u0026#34;, t, len(t), cap(t)) } 输出结果：\nt:[2 3] len(t):2 cap(t):4 完整切片表达式需要满足的条件是0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a)，其他条件和简单切片表达式相同。\n2.1.3 使用make()函数构造切片 我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的make()函数，格式如下：\nmake([]T, size, cap) 其中：\nT:切片的元素类型 size:切片中元素的数量 cap:切片的容量 举个例子：\nfunc main() { a := make([]int, 2, 10) fmt.Println(a) //[0 0] fmt.Println(len(a)) //2 fmt.Println(cap(a)) //10 } 上面代码中a的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以len(a)返回2，cap(a)则返回该切片的容量。\n2.1.4 切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。\n举个例子，现在有一个数组a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}，切片s1 := a[:5]，相应示意图如下。\n切片s2 := a[3:6]，相应示意图如下：\n2.1.5 判断切片是否为空 要检查切片是否为空，请始终使用len(s) == 0来判断，而不应该使用s == nil来判断。\n2.2 切片不能直接比较 切片之间是不能比较的，我们不能使用==操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和nil比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是nil，例如下面的示例：\nvar s1 []int //len(s1)=0;cap(s1)=0;s1==nil s2 := []int{} //len(s2)=0;cap(s2)=0;s2!=nil s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil 所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。\n2.3 切片的赋值拷贝 下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。\nfunc main() { s1 := make([]int, 3) //[0 0 0] s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0] } 2.4 切片遍历 切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。\nfunc main() { s := []int{1, 3, 5} for i := 0; i \u0026lt; len(s); i++ { fmt.Println(i, s[i]) } for index, value := range s { fmt.Println(index, value) } } 2.5 append()方法为切片添加元素 Go语言的内建函数append()可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。\nfunc main(){ var s []int s = append(s, 1) // [1] s = append(s, 2, 3, 4) // [1 2 3 4] s2 := []int{5, 6, 7} s = append(s, s2...) // [1 2 3 4 5 6 7] } **注意：**通过var声明的零值切片可以在append()函数直接使用，无需初始化。\nvar s []int s = append(s, 1, 2, 3) 没有必要像下面的代码一样初始化一个切片再传入append()函数使用，\ns := []int{} // 没有必要初始化 s = append(s, 1, 2, 3) var s = make([]int) // 没有必要初始化 s = append(s, 1, 2, 3) 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值。\n举个例子：\nfunc main() { //append()添加元素和切片扩容 var numSlice []int for i := 0; i \u0026lt; 10; i++ { numSlice = append(numSlice, i) fmt.Printf(\u0026#34;%v len:%d cap:%d ptr:%p\\n\u0026#34;, numSlice, len(numSlice), cap(numSlice), numSlice) } } 输出：\n[0] len:1 cap:1 ptr:0xc0000a8000 [0 1] len:2 cap:2 ptr:0xc0000a8040 [0 1 2] len:3 cap:4 ptr:0xc0000b2020 [0 1 2 3] len:4 cap:4 ptr:0xc0000b2020 [0 1 2 3 4] len:5 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5] len:6 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6] len:7 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7] len:8 cap:8 ptr:0xc0000b6000 [0 1 2 3 4 5 6 7 8] len:9 cap:16 ptr:0xc0000b8000 [0 1 2 3 4 5 6 7 8 9] len:10 cap:16 ptr:0xc0000b8000 从上面的结果可以看出：\nappend()函数将元素追加到切片的最后并返回该切片。 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。 append()函数还支持一次性追加多个元素。 例如：\nvar citySlice []string // 追加一个元素 citySlice = append(citySlice, \u0026#34;北京\u0026#34;) // 追加多个元素 citySlice = append(citySlice, \u0026#34;上海\u0026#34;, \u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;) // 追加切片 a := []string{\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;} citySlice = append(citySlice, a...) fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆] 2.6 切片的扩容策略 可以通过查看$GOROOT/src/runtime/slice.go源码，其中扩容相关代码如下：\nnewcap := old.cap doublecap := newcap + newcap if cap \u0026gt; doublecap { newcap = cap } else { if old.len \u0026lt; 1024 { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } 从上面的代码可以看出以下内容：\n首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）， 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap \u0026gt;= cap） 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。 需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如int和string类型的处理方式就不一样。\n2.7 使用copy()函数复制切片 首先我们来看一个问题：\nfunc main() { a := []int{1, 2, 3, 4, 5} b := a fmt.Println(a) //[1 2 3 4 5] fmt.Println(b) //[1 2 3 4 5] b[0] = 1000 fmt.Println(a) //[1000 2 3 4 5] fmt.Println(b) //[1000 2 3 4 5] } 由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。\nGo语言内建的copy()函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：\ncopy(destSlice, srcSlice []T) 其中：\nsrcSlice: 数据来源切片 destSlice: 目标切片 举个例子：\nfunc main() { // copy()复制切片 a := []int{1, 2, 3, 4, 5} c := make([]int, 5, 5) copy(c, a) //使用copy()函数将切片a中的元素复制到切片c fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1 2 3 4 5] c[0] = 1000 fmt.Println(a) //[1 2 3 4 5] fmt.Println(c) //[1000 2 3 4 5] } 2.8 从切片中删除元素 Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：\nfunc main() { // 从切片中删除元素 a := []int{30, 31, 32, 33, 34, 35, 36, 37} // 要删除索引为2的元素 a = append(a[:2], a[3:]...) fmt.Println(a) //[30 31 33 34 35 36 37] } 总结一下就是：要从切片a中删除索引为index的元素，操作方法是a = append(a[:index], a[index+1:]...)\n3.练习题 1.请写出下面代码的输出结果。\nfunc main() { var a = make([]string, 5, 10) for i := 0; i \u0026lt; 10; i++ { a = append(a, fmt.Sprintf(\u0026#34;%v\u0026#34;, i)) } fmt.Println(a) } [\u0026quot;\u0026quot; \u0026quot;\u0026quot; \u0026quot;\u0026quot; \u0026quot;\u0026quot; \u0026ldquo;\u0026ldquo;0 1 2 3 4 5 6 7 8 9]\n2.请使用内置的sort包对数组var a = [...]int{3, 7, 8, 9, 1}进行排序（附加题，自行查资料解答）。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func main() { var a = [...]int{3, 7, 8, 9, 1} // convert from fixed array to slice a_slice := a[:] // sort slice by built-in sort function sort.Ints(a_slice) // output sorted result fmt.Println(a_slice) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_slice/","summary":"本文主要介绍Go语言中切片（slice）及它的基本使用。 1.引子 因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如： func arraySum(x [3]int) int{ sum := 0 for _, v := range x{ sum = sum + v } return sum } 这个求和函数只能接受[3]int类型，其他的都不支持。 再比如， a := [3]int{1, 2, 3} 数组a中已经有三个","title":"Golang切片"},{"content":"本文主要介绍Go语言中数组（array）及它的基本使用。\n1.Array(数组) 数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：\n// 定义一个长度为3元素类型为int的数组a var a [3]int 1.1 数组定义 var 数组变量名 [元素数量]T 比如：var a [5]int， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 [5]int和[10]int是不同的类型。\nvar a [3]int var b [4]int a = b //不可以这样做，因为此时a和b是不同的类型 数组可以通过下标进行访问，下标是从0开始，最后一个元素下标是：len-1，访问越界（下标在合法范围之外），则触发访问越界，会panic。\n1.2 数组的初始化 数组的初始化也有很多方式。\n方法一 初始化数组时可以使用初始化列表来设置数组元素的值。\nfunc main() { var testArray [3]int //数组会初始化为int类型的零值 var numArray = [3]int{1, 2} //使用指定的初始值完成初始化 var cityArray = [3]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} //使用指定的初始值完成初始化 fmt.Println(testArray) //[0 0 0] fmt.Println(numArray) //[1 2 0] fmt.Println(cityArray) //[北京 上海 深圳] } 方法二 按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：\nfunc main() { var testArray [3]int var numArray = [...]int{1, 2} var cityArray = [...]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} fmt.Println(testArray) //[0 0 0] fmt.Println(numArray) //[1 2] fmt.Printf(\u0026#34;type of numArray:%T\\n\u0026#34;, numArray) //type of numArray:[2]int fmt.Println(cityArray) //[北京 上海 深圳] fmt.Printf(\u0026#34;type of cityArray:%T\\n\u0026#34;, cityArray) //type of cityArray:[3]string } 方法三 我们还可以使用指定索引值的方式来初始化数组，例如:\nfunc main() { a := [...]int{1: 1, 3: 5} fmt.Println(a) // [0 1 0 5] fmt.Printf(\u0026#34;type of a:%T\\n\u0026#34;, a) //type of a:[4]int } 1.3 数组的遍历 遍历数组a有以下两种方法：\nfunc main() { var a = [...]string{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;深圳\u0026#34;} // 方法1：for循环遍历 for i := 0; i \u0026lt; len(a); i++ { fmt.Println(a[i]) } // 方法2：for range遍历 for index, value := range a { fmt.Println(index, value) } } 1.4 多维数组 Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。\n1.4.1 二维数组的定义 func main() { a := [3][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]] fmt.Println(a[2][1]) //支持索引取值:重庆 } 1.4.2 二维数组的遍历 func main() { a := [3][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } for _, v1 := range a { for _, v2 := range v1 { fmt.Printf(\u0026#34;%s\\t\u0026#34;, v2) } fmt.Println() } } 输出：\n北京\t上海\t广州\t深圳\t成都\t重庆 注意： 多维数组只有第一层可以使用...来让编译器推导数组长度。例如：\n//支持的写法 a := [...][2]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } //不支持多维数组的内层使用... b := [3][...]string{ {\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;}, {\u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}, {\u0026#34;成都\u0026#34;, \u0026#34;重庆\u0026#34;}, } 1.5 数组是值类型 数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。\nfunc modifyArray(x [3]int) { x[0] = 100 } func modifyArray2(x [3][2]int) { x[2][0] = 100 } func main() { a := [3]int{10, 20, 30} modifyArray(a) //在modify中修改的是a的副本x fmt.Println(a) //[10 20 30] b := [3][2]int{ {1, 1}, {1, 1}, {1, 1}, } modifyArray2(b) //在modify中修改的是b的副本x fmt.Println(b) //[[1 1] [1 1] [1 1]] } 注意：\n数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。 [n]*T表示指针数组，*[n]T表示数组指针 。 2.练习题 1.求数组[1, 3, 5, 7, 8]所有元素的和\npackage main import \u0026#34;fmt\u0026#34; func main() { var arr = [5]int{1, 3, 5, 7, 8} var sum = 0 for _, i := range arr { sum += i } fmt.Println(sum) } 2.找出数组中和为指定值的两个元素的下标，比如从数组[1, 3, 5, 7, 8]中找出和为8的两个元素的下标分别为(0,3)和(1,2)。\npackage main import \u0026#34;fmt\u0026#34; func main() { var arr = [5]int{1, 3, 5, 7, 8} for i, j := range arr { for a, b := range arr[i+1:] { if j+b == 8 { fmt.Printf(\u0026#34;(%d,%d)\\n\u0026#34;, i, a) } } } } ","permalink":"https://N3bu74.github.io/posts/tech/golang_array/","summary":"本文主要介绍Go语言中数组（array）及它的基本使用。 1.Array(数组) 数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法： // 定义一个长度为3元素类型为int的数组a var a [3]int 1.1 数组定义 var 数组变量名 [元素数量","title":"Golang数组"},{"content":"流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。\nGo语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。\n1.流程控制 1.1 if else(分支结构) 1.1.1 if条件判断基本写法 Go语言中if条件判断的格式如下：\nif 表达式1 { 分支1 } else if 表达式2 { 分支2 } else{ 分支3 } 当表达式1的结果为true时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的else if和else都是可选的，可以根据实际需要进行选择。\nGo语言规定与if匹配的左括号{必须与if和表达式放在同一行，{放在其他位置会触发编译错误。 同理，与else匹配的{也必须与else写在同一行，else也必须与上一个if或else if右边的大括号在同一行。\n举个例子：\nfunc ifDemo1() { score := 65 if score \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt; 75 { fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } } 1.1.2 if条件判断特殊写法 if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：\nfunc ifDemo2() { if score := 65; score \u0026gt;= 90 { fmt.Println(\u0026#34;A\u0026#34;) } else if score \u0026gt; 75 { fmt.Println(\u0026#34;B\u0026#34;) } else { fmt.Println(\u0026#34;C\u0026#34;) } } 思考题： 上下两种写法的区别在哪里？\n前一种score的作用域在func中，后一种的作用域在if中\n1.2 for(循环结构) Go 语言中的所有循环类型均可以使用for关键字来完成。\nfor循环的基本格式如下：\nfor 初始语句;条件表达式;结束语句{ 循环体语句 } 条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。\nfunc forDemo() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：\nfunc forDemo2() { i := 0 for ; i \u0026lt; 10; i++ { fmt.Println(i) } } for循环的初始语句和结束语句都可以省略，例如：\nfunc forDemo3() { i := 0 for i \u0026lt; 10 { fmt.Println(i) i++ } } 这种写法类似于其他编程语言中的while，在while后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。\n1.2.1 无限循环 for { 循环体语句 } for循环可以通过break、goto、return、panic语句强制退出循环。\n1.3 for range(键值循环) Go语言中可以使用for range遍历数组、切片、字符串、map 及通道（channel）。 通过for range遍历的返回值有以下规律：\n数组、切片、字符串返回索引和值。 map返回键和值。 通道（channel）只返回通道内的值。 1.4 switch case 使用switch语句可方便地对大量的值进行条件判断。\nfunc switchDemo1() { finger := 3 switch finger { case 1: fmt.Println(\u0026#34;大拇指\u0026#34;) case 2: fmt.Println(\u0026#34;食指\u0026#34;) case 3: fmt.Println(\u0026#34;中指\u0026#34;) case 4: fmt.Println(\u0026#34;无名指\u0026#34;) case 5: fmt.Println(\u0026#34;小拇指\u0026#34;) default: fmt.Println(\u0026#34;无效的输入！\u0026#34;) } } Go语言规定每个switch只能有一个default分支。\n一个分支可以有多个值，多个case值中间使用英文逗号分隔。\nfunc testSwitch3() { switch n := 7; n { case 1, 3, 5, 7, 9: fmt.Println(\u0026#34;奇数\u0026#34;) case 2, 4, 6, 8: fmt.Println(\u0026#34;偶数\u0026#34;) default: fmt.Println(n) } } 分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量。例如：\nfunc switchDemo4() { age := 30 switch { case age \u0026lt; 25: fmt.Println(\u0026#34;好好学习吧\u0026#34;) case age \u0026gt; 25 \u0026amp;\u0026amp; age \u0026lt; 35: fmt.Println(\u0026#34;好好工作吧\u0026#34;) case age \u0026gt; 60: fmt.Println(\u0026#34;好好享受吧\u0026#34;) default: fmt.Println(\u0026#34;活着真好\u0026#34;) } } fallthrough语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。\nfunc switchDemo5() { s := \u0026#34;a\u0026#34; switch { case s == \u0026#34;a\u0026#34;: fmt.Println(\u0026#34;a\u0026#34;) fallthrough case s == \u0026#34;b\u0026#34;: fmt.Println(\u0026#34;b\u0026#34;) case s == \u0026#34;c\u0026#34;: fmt.Println(\u0026#34;c\u0026#34;) default: fmt.Println(\u0026#34;...\u0026#34;) } } 输出：\na b 1.5 goto(跳转到指定标签) goto语句通过标签进行代码间的无条件跳转。goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用goto语句能简化一些代码的实现过程。 例如双层嵌套的for循环要退出时：\nfunc gotoDemo1() { var breakFlag bool for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 breakFlag = true break } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } // 外层for循环判断 if breakFlag { break } } } 使用goto语句能简化代码：\nfunc gotoDemo2() { for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { // 设置退出标签 goto breakTag } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } return // 标签 breakTag: fmt.Println(\u0026#34;结束for循环\u0026#34;) } 1.6 break(跳出循环) break语句可以结束for、switch和select的代码块。\nbreak语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和 select的代码块上。 举个例子：\nfunc breakDemo1() { BREAKDEMO1: for i := 0; i \u0026lt; 10; i++ { for j := 0; j \u0026lt; 10; j++ { if j == 2 { break BREAKDEMO1 } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } fmt.Println(\u0026#34;...\u0026#34;) } 1.7 continue(继续下次循环) continue语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用。\n在 continue语句后添加标签时，表示继续标签对应的循环。例如：\nfunc continueDemo() { forloop1: for i := 0; i \u0026lt; 5; i++ { // forloop2: for j := 0; j \u0026lt; 5; j++ { if i == 2 \u0026amp;\u0026amp; j == 2 { continue forloop1 } fmt.Printf(\u0026#34;%v-%v\\n\u0026#34;, i, j) } } } 2.练习题 编写代码打印9*9乘法表。 package main import \u0026#34;fmt\u0026#34; func main() { for i := 1; i \u0026lt;= 10; i++ { for j := 1; j \u0026lt;= i; j++ { fmt.Printf(\u0026#34;%-2d * %-2d = %-2d \u0026#34;, i, j, i*j) } fmt.Println() } } ","permalink":"https://N3bu74.github.io/posts/tech/golang_flow_control/","summary":"流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。 Go语言中最常用的流程控制有if和for，而switch和goto主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。 1.流程控制 1.1 if else(分支结构) 1.1.1 if条件判断基本写","title":"Golang流程控制"},{"content":"1.运算符 Go 语言内置的运算符有：\n算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 1.1 算术运算符 运算符 描述 + 相加 - 相减 * 相乘 / 相除 % 求余 注意： ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符。（有a++，没有++a;同\u0026ndash;）\n1.2 关系运算符 运算符 描述 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 \u0026gt; 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 \u0026gt;= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 \u0026lt; 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 \u0026lt;= 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 1.3 逻辑运算符 运算符 描述 \u0026amp;\u0026amp; 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 || 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 ! 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 1.4 位运算符 位运算符对整数在内存中的二进制位进行操作。\n运算符 描述 \u0026amp; 参与运算的两数各对应的二进位相与。 （两位均为1才为1） | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1） ^ 参与运算的两数各对应的二进制位相异或，当两对应的二进制位相异时，结果为1。 （两位不一样则为1） \u0026laquo; 左移n位就是乘以2的n次方。 “a\u0026laquo;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 \u0026raquo; 右移n位就是除以2的n次方。 “a\u0026raquo;b”是把a的各二进位全部右移b位。 1.5 赋值运算符 运算符 描述 = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 \u0026laquo;= 左移后赋值 \u0026raquo;= 右移后赋值 \u0026amp;= 按位与后赋值 |= 按位或后赋值 ^= 按位异或后赋值 2.练习题 有一堆数字，如果除了一个数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？\npackage main import \u0026#34;fmt\u0026#34; func main() { var arr = [...]int{4, 2, 3, 4, 2, 1, 3} result := 0 for _, a := range arr { result ^= a } fmt.Println(result) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_operator/","summary":"1.运算符 Go 语言内置的运算符有： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 1.1 算术运算符 运算符 描述 + 相加 - 相减 * 相乘 / 相除 % 求余 注意： ++（自增）和--（自减）在Go语言中是单独的语句，并不是运算符。（有a++，没有++a;同\u0026ndash;） 1.2 关系运算符 运算符 描述 == 检查两个值","title":"Golang运算符"},{"content":"Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。\n1.基本数据类型 1.1 整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64\n其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。\n类型 描述 uint8 无符号 8位整型 (0 到 255) uint16 无符号 16位整型 (0 到 65535) uint32 无符号 32位整型 (0 到 4294967295) uint64 无符号 64位整型 (0 到 18446744073709551615) int8 有符号 8位整型 (-128 到 127) int16 有符号 16位整型 (-32768 到 32767) int32 有符号 32位整型 (-2147483648 到 2147483647) int64 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) 1.1.1 特殊整型 类型 描述 uint 32位操作系统上就是uint32，64位操作系统上就是uint64 int 32位操作系统上就是int32，64位操作系统上就是int64 uintptr 无符号整型，用于存放一个指针 注意： 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。\n注意事项 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint。\n1.1.2 数字字面量语法（Number literals syntax） Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：\nv := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。\n而且还允许我们用 _ 来分隔数字，比如说： v := 123_456 表示 v 的值等于 123456。\n我们可以借助fmt函数来将一个整数以不同进制形式展示。\npackage main import \u0026#34;fmt\u0026#34; func main(){ // 十进制 var a int = 10 fmt.Printf(\u0026#34;%d \\n\u0026#34;, a) // 10 fmt.Printf(\u0026#34;%b \\n\u0026#34;, a) // 1010 占位符%b表示二进制 // 八进制 以0开头 var b int = 077 fmt.Printf(\u0026#34;%o \\n\u0026#34;, b) // 77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(\u0026#34;%x \\n\u0026#34;, c) // ff fmt.Printf(\u0026#34;%X \\n\u0026#34;, c) // FF } 1.2 浮点型 Go语言支持两种浮点型数：`float32`和`float64`。这两种浮点型数据格式遵循`IEEE 754`标准： `float32` 的浮点数的最大范围约为 `3.4e38`，可以使用常量定义：`math.MaxFloat32`。 `float64` 的浮点数的最大范围约为 `1.8e308`，可以使用一个常量定义：`math.MaxFloat64`。\r打印浮点数时，可以使用fmt包配合动词%f，代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Printf(\u0026#34;%f\\n\u0026#34;, math.Pi) fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, math.Pi) } 1.3 复数 complex64和complex128\nvar c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。\n1.4 布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。\n注意：\n布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。 1.5 字符串 ​\tGo语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(\u0026quot;)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：\ns1 := \u0026#34;hello\u0026#34; s2 := \u0026#34;你好\u0026#34; 1.5.1 字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。\n转义符 含义 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\u0026quot; 双引号 \\\\ 反斜杠 举个例子，我们要打印一个Windows平台下的一个文件路径：\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;str := \\\u0026#34;c:\\\\Code\\\\lesson1\\\\go.exe\\\u0026#34;\u0026#34;) } 1.5.2 多行字符串 Go语言中要定义一个多行字符串时，就必须使用反引号字符：\ns1 := `第一行 第二行 第三行 ` fmt.Println(s1) 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。\n1.5.3 字符串的常用操作 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join操作 1.6 byte和rune类型 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：\nvar a = \u0026#39;中\u0026#39; var b = \u0026#39;x\u0026#39; Go 语言的字符有以下两种：\nuint8类型，或者叫 byte 型，代表一个ASCII码字符。 rune类型，代表一个 UTF-8字符。 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。\nGo 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。\n// 遍历字符串 func traversalString() { s := \u0026#34;hello沙河\u0026#34; for i := 0; i \u0026lt; len(s); i++ { //byte fmt.Printf(\u0026#34;%v(%c) \u0026#34;, s[i], s[i]) } fmt.Println() for _, r := range s { //rune fmt.Printf(\u0026#34;%v(%c) \u0026#34;, r, r) } fmt.Println() } 输出：\n104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。\n字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。\n1.6.1 修改字符串 ​\t要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。\nfunc changeString() { s1 := \u0026#34;big\u0026#34; // 强制类型转换 byteS1 := []byte(s1) byteS1[0] = \u0026#39;p\u0026#39; fmt.Println(string(byteS1)) s2 := \u0026#34;白萝卜\u0026#34; runeS2 := []rune(s2) runeS2[0] = \u0026#39;红\u0026#39; fmt.Println(string(runeS2)) } 1.7 类型转换 Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。\n强制类型转换的基本语法如下：\nT(表达式) 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.\n比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。\nfunc sqrtDemo() { var a, b = 3, 4 var c int // math.Sqrt()接收的参数是float64类型，需要强制转换 c = int(math.Sqrt(float64(a*a + b*b))) fmt.Println(c) } 2.练习题 2.1 编写代码分别定义一个整型、浮点型、布尔型、字符串型变量，使用fmt.Printf()搭配%T分别打印出上述变量的值和类型。\npackage main import \u0026#34;fmt\u0026#34; func main() { var ( a = 18 b = 9.9 c = true d = \u0026#34;N3bu74\u0026#34; ) fmt.Printf(\u0026#34;%v 是 %T类型\\n\u0026#34;, a, a) fmt.Printf(\u0026#34;%v 是 %T类型\\n\u0026#34;, b, b) fmt.Printf(\u0026#34;%v 是 %T类型\\n\u0026#34;, c, c) fmt.Printf(\u0026#34;%v 是 %T类型\\n\u0026#34;, d, d) } 2.2 编写代码统计出字符串\u0026quot;hello沙河小王子\u0026quot;中汉字的数量。\npackage main import \u0026#34;fmt\u0026#34; func main() { str := \u0026#34;hello沙河小王子\u0026#34; count := 0 for _, i := range str { if len(string(i)) \u0026gt;= 3 { count++ } } fmt.Printf(\u0026#34;中文字符有%d个\u0026#34;, count) } ","permalink":"https://N3bu74.github.io/posts/tech/golang_datatype/","summary":"Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。 1.基本数据类型 1.1 整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无","title":"Golang基本数据类型"},{"content":"1.标识符与关键字 1.1 标识符 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和`_`(下划线）组成，并且只能以字母和`_`开头。 举几个例子：`abc`, `_`, `_123`, `a123`。\r1.2 关键字 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。\rGolang中有25个关键字：\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，Golang中还有37个保留字。\nConstants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error Functions: make len cap new append copy close delete complex real imag panic recover 2.变量 2.1 标准声明 声明一个变量 ，值为该数据类型的默认值\nvar 变量名 变量类型\nvar a int fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Printf(\u0026#34;type of a = %T\\n\u0026#34;, a) //printf中的f表示格式化输出 2.2 批量声明 每声明一个变量就需要写 var关键字会比较繁琐，go语言中还支持批量变量声明：\nvar ( a string b int c bool d float32 ) 2.3 变量的初始化 Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值。\r例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。\n2.3.1 标准初始化 当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：\nvar 变量名 类型 = 表达式\n举个栗子\nvar name string = \u0026#34;Nebula\u0026#34; var age int = 18 或者一次初始化多个变量\nvar name, age = \u0026#34;Nebula\u0026#34;, 20 2.3.2 类型推导 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。\rvar name = \u0026#34;Nebula\u0026#34; var age = 18 2.3.3 短变量声明(常用) 在 函数内部，可以使用更简略的 := 方式声明并初始化变量。（:= 不能用于声明全局变量）\n注意 := 左侧的变量不应该是已经声明过的，否则会导致编译错误\npackage main import ( \u0026#34;fmt\u0026#34; ) // 全局变量m var m = 100 func main() { n := 10 m := 200 // 此处声明局部变量m fmt.Println(m, n) } 2.3.4 匿名变量 在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如：\nfunc foo() (int, string) { return 18, \u0026#34;Nebula\u0026#34; } func main() { x, _ := foo() _, y := foo() fmt.Println(\u0026#34;x=\u0026#34;, x) fmt.Println(\u0026#34;y=\u0026#34;, y) } 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)\n注意事项：\n函数外的每个语句都必须以关键字开始（var、const、func等） :=不能使用在函数外。 _多用于占位，表示忽略值。 3.常量 3.1 常量 使用 const 定义常量\n​\t相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。\nconst pi = 3.1415 const e = 2.7182 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。\n多个常量也可以一起声明：\nconst ( pi = 3.1415 e = 2.7182 ) const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：\nconst ( n1 = 100 n2 n3 ) 上面示例中，常量n1、n2、n3的值都是100。\n3.2 iota iota是go语言的常量计数器，只能在常量的表达式中使用。\n可以在const() 添加一个关键字 iota ，每行的iota都会累加1，第一行的iota的默认值为0\n使用iota能简化定义，在定义枚举时很有用。\nconst ( BEIJING = 10 * iota //iota =0 SHANGHAI //iota =1 SHENZHEN //iota =2 ) const ( a, b = iota + 1, iota + 2 //iota = 0, a= iota + 1，b =iota +2, a = 1, b = 2 c, d //iota = 1, c= iota + 1, d =iota +2, c = 2, d = 3 e, f //iota = 2, e =iota + 1, f =iota +2, e = 3, f = 4 g, h = iota * 2, iota * 3 //iota = 3, g =iota*2, h =iota *3 ,g =6 ,h = 9 i, k //iota = 4, i =iota*2, k =iota *3 ,i =8 ,k = 12 ) 3.2.1 几个常见的 iota示例: 使用_跳过某些值\nconst ( n1 = iota //0 n2 //1 _ n4 //3 ) iota声明中间插队\nconst ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 定义数量级 （这里的\u0026lt;\u0026lt;表示左移操作，1\u0026lt;\u0026lt;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2\u0026lt;\u0026lt;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）\nconst ( _ = iota KB = 1 \u0026lt;\u0026lt; (10 * iota) MB = 1 \u0026lt;\u0026lt; (10 * iota) GB = 1 \u0026lt;\u0026lt; (10 * iota) TB = 1 \u0026lt;\u0026lt; (10 * iota) PB = 1 \u0026lt;\u0026lt; (10 * iota) ) 多个iota定义在一行\nconst ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) ","permalink":"https://N3bu74.github.io/posts/tech/golang_variables_const/","summary":"1.标识符与关键字 1.1 标识符 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和`_`(下划线）组成，并且只能以字母和`_`开头。 举几个例子：`abc`, `_`, `_123`, `a123`。 1.2 关键字 关键字是指编程语言中预先定义好的具有特殊含","title":"Golang 变量与常量"},{"content":"1.站点生成 1.1 安装 Hugo GitHub地址 : https://github.com/gohugoio/hugo\n在 hugo github 的 release 中下载最新extended版, 因为只有 extended版可能将 scss 转成 css 样式 , 将 解压后的 hugo 可执行文件所在路径添加到环境变量中。\n在命令行中, 输入 hugo version 命令测试, 输出版本号说明安装OK\n1.2 新建网站 在 D:\\SitePath 生成 网站目录 SiteName ，在网站目录下会生成一个 config.toml 配置文件\ncd D:\\\\SitePath hugo new site SiteName 1.3 安装主题 一般地，假如这里选择的主题是 LoveIt , 直接把主题克隆到 themes 目录:\ngit clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 然后修改配置文件 (config.toml),进行基础配置：https://fixit.lruihao.cn/zh-cn/theme-documentation-basics/#basic-configuration\n但这里我选择的是 sulv-hugo-papermod，它是根据Hugo PaperMod主题修改而来: https://github.com/adityatelange/hugo-PaperMod\ngit clone https://github.com/xyming108/sulv-hugo-papermod cd .. git submodule update --init 1.4 新建文章 在 content 下先生成一个 posts 子目录, 然后新建文章 HugoStart.md ，文章开头会包含一些元信息。\ncd D:\\\\SitePath\\\\SiteName hugo new posts/Hugo_Start.md 1.5 在本地启动网站 Hugo 可以启动一个 Web 服务器，同时构建站点内容到内存中并在检测到文件更改后重新渲染，方便我们在开发环境实时预览对站点所做的更改。\nhugo serve -v -D 或者 hugo serve -e production # development 环境下开启评论系统, CDN 和 fingerprint 添加 -D 选项以输出草稿状态的文章，执行成功后可以通过 http://localhost:1313/ 访问站点。\n1.6 构建网站 当你准备好部署你的网站时, 运行以下命令:\nhugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上.\n1.7 目录结构 . ├── archetypes # markdown文章的模版,包括文章前缀注释写法 ├── config.toml # 配置文件 ├── content # 网站内容，主要保存文章 ├── data # 生成网站可用的数据文件，可用在模版中 ├── layouts # 生成网站时可用的模版 ├── public # 通过hugo命令生成的静态文件，这是我们网站真正要发布的目录 ├── resources # 通过hugo命令一起生成的资源文件，貌似是临时文件 ├── assets # 静态文件，比如文章中的图片/视频文件、css等, 将来其下的子目录和文件会在生成时候会自动复制到 public 目录中. ├── static # 静态文件，比如favicon等图标, 以及site.xml等, 将来其下的子目录和文件会在生成时候会自动复制到 public 目录中. └── themes # 保存可用的hugo主题 markdown文件和资源的组织形式:\n1. 博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 2. 简单的静态页面存放在 content 目录, 例如: content/about.md 3. 博文图片, 推荐放在网站的 assets 目录下, 需要新建这个目录, 比如图片放到 assets\\images 4. 音频文件, 推荐放到 assets\\music 子目录下. 5. 博文中引用的 css 样式, 推荐放到 assets\\css 子目录下. 6. favicon 以及 andriod 下的图标和网站的一些 site.xml 推荐放到static 目录下. 7. 图标/图片/css如何引用? 比如 mkdown 文件如何引用图片? hugo构建时候会将assets和static下的所有内容复制到 public 目录中, 所以mkdown 文件引用图片就可以使用下面的写法 ![](/images/wechat.png) 2.GitHub Pages 发布 2.1 创建一个 Github Pages 仓库 Create a new repository , Repository name 填 用户名.github.io ，Create 。\n2.2 发布 新建本地 git 仓库\n添加静态网页文件添加到本地仓库\n提交到github仓库\ncd public git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/N3bu74/N3bu74.github.io.git git push -u origin main 2.3 更新 git add . git commit -m \u0026#34;first commit\u0026#34; git push https://github.com/N3bu74/N3bu74.github.io.git ","permalink":"https://N3bu74.github.io/posts/blog/hugostart/","summary":"1.站点生成 1.1 安装 Hugo GitHub地址 : https://github.com/gohugoio/hugo 在 hugo github 的 release 中下载最新extended版, 因为只有 extended版可能将 scss 转成 css 样式 , 将 解压后的 hugo 可执行文件所在路径添加到环境变量中。 在命令行中, 输入 hugo version 命令测试, 输出版本号说明安装OK 1.2 新建网站 在 D:\\SitePath 生成 网站目录 SiteName ，在网站目录下会生成一个 config.toml","title":"HugoStart"}]